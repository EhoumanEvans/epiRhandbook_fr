
<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Restructurer les données {#pivoting_data}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

Dans le contexte de la gestion des données, le *pivot des données* réferer à l'un des deux processus suivants :  

1. La création de *tableaux croisés*, qui sont des tableaux de statistiques résumant les données d'un tableau plus étendu.  

2. La restructuration d'un tableau du format **long** au format **large**, ou vice versa. 

Dans ce chapitre, nous allons nous focaliser sur le second processus. Résumer ses données dans des tableau est une étape cruciale de l'analyse des données et est traitée dans les chapitres sur [le regroupement des données](#grouping_data) et les [tableaux descriptifs](#descriptive_tables). 

Ce chapitre traite des formats de données. Il est utile de connaître l'idée de "données rangées", dans laquelle chaque variable a sa propre colonne, chaque observation a sa propre ligne et chaque valeur a sa propre cellule. Vous trouverez plus d'informations sur ce sujet [dans ce chapitre en ligne de R for Data Science](https://r4ds.had.co.nz/tidy-data.html). 


## Étapes préliminaires  

### Importation des paquets {.unnumbered}  

Ces lignes de code chargent les paquets nécessaires aux analyses. Dans ce guide, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *puis* l'importe pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [bases de R](#rbasics) pour plus d'informations sur les paquets R.  


```{r}
pacman::p_load(
  rio,          # import des fichiers
  here,         # gestion des chemins d'accès
  tidyverse)    # gestion des données + graphiques (ggplot2)
```



### Importation des données {.unnumbered}


### Cas de Malaria {-}  

Dans ce chapitre, nous utiliserons un jeu de données fictif de cas quotidiens de paludisme, par établissement et par groupe d'âge. Pour reproduire les étapes, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>cliquez ici pour télécharger les données (en tant que fichier .rds)<span></a>. Ou importez des données avec la fonction `import()` du paquet **rio** (elle gère de nombreux types de fichiers comme .xlsx, .csv, .rds - voir la page [Importation et exportation des données](import_export) pour plus de détails).  


```{r, echo=F}
count_data <- rio::import(
  here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Importation des données
count_data <- import("malaria_facility_count_data.rds")
```

Les premières cinquantes lignes sont affichées ci-dessous.  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), 
              rownames = FALSE, 
              options = list(pageLength = 5, scrollX = T), 
              class = 'white-space: nowrap' )
```


### Linelist des cas {-}  

A la fin de ce chapitre, nous utiliserons également une liste des cas d'une épidémie d'Ebola simulée. Pour reproduire les étapes, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la linelist "propre"</a> (en tant que fichier .rds). Importez vos données avec la fonction `import()` du paquet **rio** (elle accepte de nombreux types de fichiers comme .xlsx, .rds, .csv - voir la page [Importation et exportation des données](import_export) pour plus de détails).  


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# Importer la linelist
linelist <- import("linelist_cleaned.xlsx")
```



<!-- ======================================================= -->
## Transformation du format larger vers long {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```


<!-- ======================================================= -->
### Le format "large" {.unnumbered}

Les données sont souvent saisies et stockées dans un format "large", où les caractéristiques ou les réponses d'un sujet/d'un item sont entrées dans une même ligne. Cette structure de données est utile pour la saisie et la présentation des données, mais elle n'est pas appropriée pour de nombreuses analyses.  

Par exemple, dans le jeu de données `count_data` importé auparavant, chaque ligne représente un établissement à une date donnée. Les nombres de cas 
sont contenus dans les colonnes les plus à droites, avec une colonne par classe d'age, et une colonne pour le nombre total de cas ce jour là dans cet établissement. L'information "nombre de cas" est donc contenues sur plusieurs colonnes, au lieu d'une seule, d'où la structure dite "large".


```{r, echo=F}
DT::datatable(count_data, 
              rownames = FALSE, 
              options = list(pageLength = 10, 
                             scrollX = T) )
```

Plus précisément, chaque ligne dans ce tableau se réfère aux nombre de cas de paludisme dans l'un des 65 établissements à une date donnée, dans la période allant de ` count_data$data_date %>% min()` à ` count_data$data_date %>% max()`. Ces établissements sont situés dans une `province` (Nord) et quatre `districts` (Spring, Bolo, Dingo, et Barnard). L'ensemble de données fournit les totaux globaux des cas de paludisme, ainsi que les totaux pour chaque classe d'age (<4 ans, 5-14 ans, et 15 ans et plus).

Les données sous format "large" comme celle-ci ne respectent pas les normes de "données rangées", car les en-têtes de colonne ne représentent pas réellement des "variables": ils contiennent les *valeurs* d'une hypothétique variable "groupe d'âge".

Ce format est utile pour présenter les informations dans un tableau, ou pour saisir des données (dans Excel par exemple) à partir de formulaires de notification des cas. Cependant, au stade de l'analyse, ces données doivent généralement être restructurées et rangées en un format plus long. Le paquet de visualisations **ggplot2**, fonctionne également mieux lorsque les données sont dans un format "long".  


La visualisation du nombre *total* de cas de paludisme dans le temps ne pose aucun problème avec les données dans leur format actuel :  

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

Cependant, les choses se compliquent si l'on veut visualiser les contributions relatives de chaque groupe d'âge au total des cas ? Nous devons alors nous assurer que la variable d'intérêt (le groupe d'âge) ait sa propre colonne dans le dataframe, colonne qui peut être passée à l'argument "mapping aesthetics" `aes()` de `{ggplot2}`.


<!-- ======================================================= -->
### `pivot_longer()` {.unnumbered}

La fonction **tidyr** `pivot_longer()` transforme un jeu de données au format "large" en un jeu de données "plus long". **tidyr** fait partie du méta-paquet **tidyverse**.   

Elle accepte une ou plusieurs colonnes à transformer (argument `cols = `), ce qui donne un contrôle fin sur les colonnes à restructurer.Par exemple, pour les données sur le paludisme, nous ne voulons faire pivoter que les colonnes contenant des nombre de cas.  

Suite à ce processus, vous obtenez deux "nouvelles" colonnes: l'une contenant les catégories (anciennement sotckées dans les noms de colonnes), et l'autre avec les valeurs correspondantes (ici, le nombre de cas). Vous pouvez accepter les noms par défaut pour ces nouvelles colonnes, ou spécifier les vôtres dans `names_to = ` et `values_to = ` respectivement.  

Voyons comment utiliser `pivot_longer()`... 



### Transformation simple {.unnumbered}  

Nous utilisons la fonction `pivot_longer()` de **tidyr** pour convertir les données d'un format "large" à un format "long". Plus précisément, il s'agit de convertir les quatre colonnes numériques contenant des nombre de cas de paludisme en deux nouvelles colonnes : une qui contient les *groupes d'âge* et une qui contient les *valeurs* correspondantes. 

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, 
             `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Notons que le dataframe nouvellement crée (`df_long`) a plus de lignes (12 152 contre 3 038) : il est devenu *plus long*. En fait, il est précisément quatre fois plus long, car chaque ligne du tableau d'origine a donné quatre lignes dans `df_long``, une pour chacun des colonnes restructurées (<4 ans, 5-14 ans, 15 ans et plus, et total).  

En plus d'être plus long, le nouveau tableau a moins de colonnes (8 contre 10), car les données précédemment stockées dans quatre colonnes (celles qui commencent par le préfixe `malaria_`) sont maintenant stockées dans deux colonnes.  


*Note :* puisque les noms de quatre colonnes transformées commencent tous par le préfixe `malaria_`, nous aurions pu sélectionner les colonnes à transformer en utilisant la fonction `starts_with()` pour obtenir le même résultat (voir la page sur [le nettoyage des données et les fonctions de base](#cleaning_data) pour plus de ces fonctions d'aide de type "tidyselect").   


```{r}
# choisir les colonnes avec l'aide d'une fonction "tidyselect"
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

ou par position :   

```{r, eval=F}
# Choisir les colonnes à partir de leur position dans le tableau
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

ou dans le cas de colonnes consécutives, avec la première et la dernière colonne :  

```{r, eval=F}
# Choisir les colonnes avec un "intervalle"
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```



These two new columns are given the default names of `name` and `value`, but we can override these defaults to provide more meaningful names, which can help remember what is stored within, using the `names_to` and `values_to` arguments. Let's use the names `age_group` and `counts`:

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

We can now pass this new dataset to `{ggplot2}`, and map the new column `count` to the y-axis and new column `age_group` to the `fill = ` argument (the column internal color). This will display the malaria counts in a stacked bar chart, by age group:

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Examine this new plot, and compare it with the plot we created earlier - *what has gone wrong?*  

We have encountered a common problem when wrangling surveillance data - we have also included the total counts from the `malaria_tot` column, so the magnitude of each bar in the plot is twice as high as it should be. 

We can handle this in a number of ways. We could simply filter these totals from the dataset before we pass it to `ggplot()`:

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Alternatively, we could have excluded this variable when we ran `pivot_longer()`, thereby maintaining it in the dataset as a separate variable. See how its values "expand" to fill the new rows. 

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```





### Pivoting data of multiple classes {.unnumbered}

The above example works well in situations in which all the columns you want to "pivot longer" are of the same class (character, numeric, logical...). 

However, there will be many cases when, as a field epidemiologist, you will be working with data that was prepared by non-specialists and which follow their own non-standard logic - as Hadley Wickham noted (referencing Tolstoy) in his [seminal article](https://vita.had.co.nz/papers/tidy-data.pdf) on **Tidy Data** principles: "Like families, tidy datasets are all alike but every messy dataset is messy in its own way."

One particularly common problem you will encounter will be the need to pivot columns that contain different classes of data. This pivot will result in storing these different data types in a single column, which is not a good situation. There are various approaches one can take to separate out the mess this creates, but there is an important step you can take using `pivot_longer()` to avoid creating such a situation yourself.

Take a situation in which there have been a series of observations at different time steps for each of three items A, B and C. Examples of such items could be individuals (e.g. contacts of an Ebola case being traced each day for 21 days) or remote village health posts being monitored once per year to ensure they are still functional. Let's use the contact tracing example. Imagine that the data are stored as follows:


```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

As can be seen, the data are a bit complicated. Each row stores information about one item, but with the time series running further and further away to the right as time progresses. Moreover, the column classes alternate between date and character values.  

One particularly bad example of this encountered by this author involved cholera surveillance data, in which 8 new columns of observations were added *each day* over the course of __4 years__. Simply opening the Excel file in which these data were stored took >10 minuntes on my laptop!

In order to work with these data, we need to transform the data frame to long format, but keeping the separation between a `date` column and a `character` (status) column, for each observation for each item. If we don't, we might end up with a mixture of variable types in a single column (a very big "no-no" when it comes to data management and tidy data):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Above, our pivot has merged *dates* and *characters* into a single `value` column. R will react by converting the entire column to class character, and the utility of the dates is lost.  

To prevent this situation, we can take advantage of the syntax structure of the original column names. There is a common naming structure, with the observation number, an underscore, and then either "status" or "date". We can leverage this syntax to keep these two data types in separate columns after the pivot. 

We do this by:  

* Providing a character vector to the `names_to = ` argument, with the second item being (`".value"` ). This special term indicates that the pivoted columns will be split based on a character in their name...  
* You must also provide the "splitting" character to the `names_sep = ` argument. In this case, it is the underscore "_".  

Thus, the naming and split of new columns is based around the underscore in the existing variable names.  

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

__Finishing touches__:

Note that the `date` column is currently in *character* class - we can easily convert this into it's proper date class using the `mutate()` and `as_date()` functions described in the [Working with dates] page.  

We may also want to convert the `observation` column to a `numeric` format by dropping the "obs" prefix and converting to numeric. We cando this with `str_remove_all()` from the **stringr** package (see the [Characters and strings] page).  

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

And now, we can start to work with the data in this format, e.g. by plotting a descriptive heat tile:  

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```





<!-- ======================================================= -->
## Long-to-wide {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```


In some instances, we may wish to convert a dataset to a wider format. For this, we can use the `pivot_wider()` function.

A typical use-case is when we want to transform the results of an analysis into a format which is more digestible for the reader (such as a [Table for presentation][Tables for presentation]). Usually, this involves transforming a dataset in which information for one subject is are spread over multiple rows into a format in which that information is stored in a single row.

### Data {.unnumbered}

For this section of the page, we will use the case linelist (see the [Preparation](#pivot_prep) section), which contains one row per case.  

Here are the first 50 rows:  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Suppose that we want to know the counts of individuals in the different age groups, by gender:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

This gives us a long dataset that is great for producing visualisations in **ggplot2**, but not ideal for presentation in a table:

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Pivot wider {.unnumbered}  

Therefore, we can use `pivot_wider()` to transform the data into a better format for inclusion as tables in our reports.  

The argument `names_from` specifies the column *from* which to generate the new column *names*, while the argument `values_from` specifies the column *from* which to take the *values* to populate the cells. The argument `id_cols = ` is optional, but can be provided a vector of column names that should not be pivoted, and will thus identify each row.  

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

This table is much more reader-friendly, and therefore better for inclusion in our reports. You can convert into a pretty table with several packages including **flextable** and **knitr**. This process is elaborated in the page [Tables for presentation].  

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

---


<!-- ======================================================= -->
## Fill 

In some situations after a `pivot`, and more commonly after a `bind`, we are left with gaps in some cells that we would like to fill.  

<!-- ======================================================= -->
### Data {.unnumbered}

For example, take two datasets, each with observations for the measurement number, the name of the facility, and the case count at that time. However, the second dataset also has a variable `Year`. 

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```


When we perform a `bind_rows()` to join the two datasets together, the `Year` variable is filled with `NA` for those rows where there was no prior information (i.e. the first dataset):


```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->
### `fill()` {.unnumbered}

In this case, `Year` is a useful variable to include, particularly if we want to explore trends over time. Therefore, we use `fill()` to *fill* in those empty cells, by specifying the column to fill and the direction (in this case **up**):

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Alternatively, we can rearrange the data so that we would need to fill in a downward direction:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

We now have a useful dataset for plotting:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

But less useful for presenting in a table, so let's practice converting this long, untidy dataframe into a wider, tidy dataframe:

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

N.B. In this case, we had to specify to only include the three variables `Facility`, `Year`, and `Cases` as the additional variable `Measurement` would interfere with the creation of the table:

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Resources  

Here is a helpful [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)

