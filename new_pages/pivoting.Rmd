
<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Restructurer les données {#pivoting_data}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

Dans le contexte de la gestion des données, le *pivot des données* réferer à l'un des deux processus suivants :  

1. La création de *tableaux croisés*, qui sont des tableaux de statistiques résumant les données d'un tableau plus étendu.  

2. La restructuration d'un tableau du format **long** au format **large**, ou vice versa. 

Dans ce chapitre, nous allons nous focaliser sur le second processus. Résumer ses données dans des tableau est une étape cruciale de l'analyse des données et est traitée dans les chapitres sur [le regroupement des données](#grouping_data) et les [tableaux descriptifs](#descriptive_tables). 

Ce chapitre traite des formats de données. Il est utile de connaître l'idée de "données rangées", dans laquelle chaque variable a sa propre colonne, chaque observation a sa propre ligne et chaque valeur a sa propre cellule. Vous trouverez plus d'informations sur ce sujet [dans ce chapitre en ligne de R for Data Science](https://r4ds.had.co.nz/tidy-data.html). 


## Étapes préliminaires  

### Importation des paquets {.unnumbered}  

Ces lignes de code chargent les paquets nécessaires aux analyses. Dans ce guide, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *puis* l'importe pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [bases de R](#rbasics) pour plus d'informations sur les paquets R.  


```{r}
pacman::p_load(
  rio,          # import des fichiers
  here,         # gestion des chemins d'accès
  tidyverse)    # gestion des données + graphiques (ggplot2)
```



### Importation des données {.unnumbered}


### Cas de Malaria {-}  

Dans ce chapitre, nous utiliserons un jeu de données fictif de cas quotidiens de paludisme, par établissement et par groupe d'âge. Pour reproduire les étapes, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>cliquez ici pour télécharger les données (en tant que fichier .rds)<span></a>. Ou importez des données avec la fonction `import()` du paquet **rio** (elle gère de nombreux types de fichiers comme .xlsx, .csv, .rds - voir la page [Importation et exportation des données](import_export) pour plus de détails).  


```{r, echo=F}
count_data <- rio::import(
  here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Importation des données
count_data <- import("malaria_facility_count_data.rds")
```

Les premières cinquantes lignes sont affichées ci-dessous.  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), 
              rownames = FALSE, 
              options = list(pageLength = 5, scrollX = T), 
              class = 'white-space: nowrap' )
```


### Linelist des cas {-}  

A la fin de ce chapitre, nous utiliserons également une liste des cas d'une épidémie d'Ebola simulée. Pour reproduire les étapes, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la linelist "propre"</a> (en tant que fichier .rds). Importez vos données avec la fonction `import()` du paquet **rio** (elle accepte de nombreux types de fichiers comme .xlsx, .rds, .csv - voir la page [Importation et exportation des données](import_export) pour plus de détails).  


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# Importer la linelist
linelist <- import("linelist_cleaned.xlsx")
```



<!-- ======================================================= -->
## Transformation du format larger vers long {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```


<!-- ======================================================= -->
### Le format "large" {.unnumbered}

Les données sont souvent saisies et stockées dans un format "large", où les caractéristiques ou les réponses d'un sujet/d'un item sont entrées dans une même ligne. Cette structure de données est utile pour la saisie et la présentation des données, mais elle n'est pas appropriée pour de nombreuses analyses.  

Par exemple, dans le jeu de données `count_data` importé auparavant, chaque ligne représente un établissement à une date donnée. Les nombres de cas 
sont contenus dans les colonnes les plus à droites, avec une colonne par classe d'age, et une colonne pour le nombre total de cas ce jour là dans cet établissement. L'information "nombre de cas" est donc contenues sur plusieurs colonnes, au lieu d'une seule, d'où la structure dite "large".


```{r, echo=F}
DT::datatable(count_data, 
              rownames = FALSE, 
              options = list(pageLength = 10, 
                             scrollX = T) )
```

Plus précisément, chaque ligne dans ce tableau se réfère aux nombre de cas de paludisme dans l'un des 65 établissements à une date donnée, dans la période allant de ` count_data$data_date %>% min()` à ` count_data$data_date %>% max()`. Ces établissements sont situés dans une `province` (Nord) et quatre `districts` (Spring, Bolo, Dingo, et Barnard). L'ensemble de données fournit les totaux globaux des cas de paludisme, ainsi que les totaux pour chaque classe d'age (<4 ans, 5-14 ans, et 15 ans et plus).

Les données sous format "large" comme celle-ci ne respectent pas les normes de "données rangées", car les en-têtes de colonne ne représentent pas réellement des "variables": ils contiennent les *valeurs* d'une hypothétique variable "groupe d'âge".

Ce format est utile pour présenter les informations dans un tableau, ou pour saisir des données (dans Excel par exemple) à partir de formulaires de notification des cas. Cependant, au stade de l'analyse, ces données doivent généralement être restructurées et rangées en un format plus long. Le paquet de visualisations **ggplot2**, fonctionne également mieux lorsque les données sont dans un format "long".  


La visualisation du nombre *total* de cas de paludisme dans le temps ne pose aucun problème avec les données dans leur format actuel :  

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

Cependant, les choses se compliquent si l'on veut visualiser les contributions relatives de chaque groupe d'âge au total des cas ? Nous devons alors nous assurer que la variable d'intérêt (le groupe d'âge) ait sa propre colonne dans le dataframe, colonne qui peut être passée à l'argument "mapping aesthetics" `aes()` de `{ggplot2}`.


<!-- ======================================================= -->
### `pivot_longer()` {.unnumbered}

La fonction **tidyr** `pivot_longer()` transforme un jeu de données au format "large" en un jeu de données "plus long". **tidyr** fait partie du méta-paquet **tidyverse**.   

Elle accepte une ou plusieurs colonnes à transformer (argument `cols = `), ce qui donne un contrôle fin sur les colonnes à restructurer.Par exemple, pour les données sur le paludisme, nous ne voulons faire pivoter que les colonnes contenant des nombre de cas.  

Suite à ce processus, vous obtenez deux "nouvelles" colonnes: l'une contenant les catégories (anciennement sotckées dans les noms de colonnes), et l'autre avec les valeurs correspondantes (ici, le nombre de cas). Vous pouvez accepter les noms par défaut pour ces nouvelles colonnes, ou spécifier les vôtres dans `names_to = ` et `values_to = ` respectivement.  

Voyons comment utiliser `pivot_longer()`... 



### Transformation simple {.unnumbered}  

Nous utilisons la fonction `pivot_longer()` de **tidyr** pour convertir les données d'un format "large" à un format "long". Plus précisément, il s'agit de convertir les quatre colonnes numériques contenant des nombre de cas de paludisme en deux nouvelles colonnes : une qui contient les *groupes d'âge* et une qui contient les *valeurs* correspondantes. 

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, 
             `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Notons que le dataframe nouvellement crée (`df_long`) a plus de lignes (12 152 contre 3 038) : il est devenu *plus long*. En fait, il est précisément quatre fois plus long, car chaque ligne du tableau d'origine a donné quatre lignes dans `df_long``, une pour chacun des colonnes restructurées (<4 ans, 5-14 ans, 15 ans et plus, et total).  

En plus d'être plus long, le nouveau tableau a moins de colonnes (8 contre 10), car les données précédemment stockées dans quatre colonnes (celles qui commencent par le préfixe `malaria_`) sont maintenant stockées dans deux colonnes.  


*Note :* puisque les noms de quatre colonnes transformées commencent tous par le préfixe `malaria_`, nous aurions pu sélectionner les colonnes à transformer en utilisant la fonction `starts_with()` pour obtenir le même résultat (voir la page sur [le nettoyage des données et les fonctions de base](#cleaning_data) pour plus de ces fonctions d'aide de type "tidyselect").   


```{r}
# choisir les colonnes avec l'aide d'une fonction "tidyselect"
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

ou par position :   

```{r, eval=F}
# Choisir les colonnes à partir de leur position dans le tableau
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

ou dans le cas de colonnes consécutives, avec la première et la dernière colonne :  

```{r, eval=F}
# Choisir les colonnes avec un "intervalle"
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```

Les deux nouvelles colonnes crées lors de la restructuration reçoivent les noms par défaut de `name` et `value`, mais nous pouvons remplacer ces valeurs par défaut par des nomsqui décrivent mieux le contenu des colonnes en utilisant les arguments `names_to` et `values_to`. Par exemple, si nous voulons renomer les colonnes `age_group` et `counts` :  

```{r}
df_long <- count_data %>% 
  pivot_longer(
    cols      = starts_with("malaria_"),
    names_to  = "age_group",
    values_to = "counts"
  )

df_long
```


Nous pouvons maintenant passer ce nouveau jeu de données à `{ggplot2}`, et placer la nouvelle colonne `count` dans l'axe des y et colorer les barres en fonction des valeurs de la colonne `age_group` grace à l'argument `fill = `. Nous obtenons alors un diagrame en baton des cas  de paludisme par groupe d'âge :  

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date,
                  y = counts, 
                  fill = age_group),
    width = 1
  )
```

Examinez ce nouveau tracé et comparez-le avec le tracé que nous avons créé précédemment : *qu'est-ce qui ne va pas ?*  

Nous fait une erreur classique du traitement des données de surveillance et inclus le nombre de cas totaux de la colonne `malaria_tot`. La conséquence est que chaque barre du graphique est deux fois plus élevée qu'elle ne devrait l'être. 

Nous pouvons résoudre ce problème de plusieurs façons. Tout d'abord nous pouvons simplement filtrer les données avant de les passer à `ggplot()` :  


```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, 
        y = counts, 
        fill = age_group),
    width = 1
  )
```

Autrement, nous aurions pu exclure cette variable lors du `pivot_longer()`, la conservant comme une variable séparée dans le tableau :   

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```

Les valeurs sont alors répetées dans les lignes des groupes d'age.



### Transformer les données de plusieurs classes {.unnumbered}

L'exemple ci-dessus fonctionne bien dans les situations où toutes les colonnes que vous voulez faire *pivoter* sont de la même classe (chaîne de caractère, numérique, logique...). 

Cependant, en tant qu'épidémiologiste de terrain, vous serez amenés à travailler avec des données qui ont été préparées par des non-spécialistes, appliquant leur propre logique, ce qui parfois aboutit à des jeux de données *non-standard*, voire totalement désorganisés. Comme Hadley Wickham l'a noté (en faisant référence à Tolstoï) dans son [article séminal](https://vita.had.co.nz/papers/tidy-data.pdf) sur les principes des **données rangées, organisées (tidy data)** : "Comme les familles, les données rangées et organisées se ressemblent toutes, mais chaque tableau désorganisé / mal rangé l'est à sa manière."   


Un problème particulièrement courant est la nécessité de restructurer des colonnes qui contiennent différentes types de données. Cette transformation aurait pour conséquence de stocker différents types de données dans une seule colonne, ce qui est déconseillé Il y a plusieurs manière de gérer les problèmes associés à ce type de données mais la restructuration avec `pivot_longer()` est une étape importante. 

Imaginons cette situation : une série d'observations a été effectuée à différents pas de temps pour chacun des trois éléments A, B et C. Il peut s'agir d'individus (par exemple, les contacts d'un cas d'Ebola sont suivis chaque jour pendant 21 jours) ou de postes de santé de villages éloignés qui sont contrôlés une fois par an pour s'assurer qu'ils sont toujours fonctionnels. Reprenons l'exemple de la recherche des contacts. Imaginons que les données soient stockées comme suit :


```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

As can be seen, the data are a bit complicated. Each row stores information about one item, but with the time series running further and further away to the right as time progresses. Moreover, the column classes alternate between date and character values.  

One particularly bad example of this encountered by this author involved cholera surveillance data, in which 8 new columns of observations were added *each day* over the course of __4 years__. Simply opening the Excel file in which these data were stored took >10 minuntes on my laptop!

In order to work with these data, we need to transform the data frame to long format, but keeping the separation between a `date` column and a `character` (status) column, for each observation for each item. If we don't, we might end up with a mixture of variable types in a single column (a very big "no-no" when it comes to data management and tidy data):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Above, our pivot has merged *dates* and *characters* into a single `value` column. R will react by converting the entire column to class character, and the utility of the dates is lost.  

To prevent this situation, we can take advantage of the syntax structure of the original column names. There is a common naming structure, with the observation number, an underscore, and then either "status" or "date". We can leverage this syntax to keep these two data types in separate columns after the pivot. 

We do this by:  

* Providing a character vector to the `names_to = ` argument, with the second item being (`".value"` ). This special term indicates that the pivoted columns will be split based on a character in their name...  
* You must also provide the "splitting" character to the `names_sep = ` argument. In this case, it is the underscore "_".  

Thus, the naming and split of new columns is based around the underscore in the existing variable names.  

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

__Finishing touches__:

Note that the `date` column is currently in *character* class - we can easily convert this into it's proper date class using the `mutate()` and `as_date()` functions described in the [Working with dates] page.  

We may also want to convert the `observation` column to a `numeric` format by dropping the "obs" prefix and converting to numeric. We cando this with `str_remove_all()` from the **stringr** package (see the [Characters and strings] page).  

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

And now, we can start to work with the data in this format, e.g. by plotting a descriptive heat tile:  

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```





<!-- ======================================================= -->
## Long-to-wide {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```


In some instances, we may wish to convert a dataset to a wider format. For this, we can use the `pivot_wider()` function.

A typical use-case is when we want to transform the results of an analysis into a format which is more digestible for the reader (such as a [Table for presentation][Tables for presentation]). Usually, this involves transforming a dataset in which information for one subject is are spread over multiple rows into a format in which that information is stored in a single row.

### Data {.unnumbered}

For this section of the page, we will use the case linelist (see the [Preparation](#pivot_prep) section), which contains one row per case.  

Here are the first 50 rows:  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Suppose that we want to know the counts of individuals in the different age groups, by gender:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

This gives us a long dataset that is great for producing visualisations in **ggplot2**, but not ideal for presentation in a table:

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Pivot wider {.unnumbered}  

Therefore, we can use `pivot_wider()` to transform the data into a better format for inclusion as tables in our reports.  

The argument `names_from` specifies the column *from* which to generate the new column *names*, while the argument `values_from` specifies the column *from* which to take the *values* to populate the cells. The argument `id_cols = ` is optional, but can be provided a vector of column names that should not be pivoted, and will thus identify each row.  

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

This table is much more reader-friendly, and therefore better for inclusion in our reports. You can convert into a pretty table with several packages including **flextable** and **knitr**. This process is elaborated in the page [Tables for presentation].  

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

---


<!-- ======================================================= -->
## Fill 

In some situations after a `pivot`, and more commonly after a `bind`, we are left with gaps in some cells that we would like to fill.  

<!-- ======================================================= -->
### Data {.unnumbered}

For example, take two datasets, each with observations for the measurement number, the name of the facility, and the case count at that time. However, the second dataset also has a variable `Year`. 

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```


When we perform a `bind_rows()` to join the two datasets together, the `Year` variable is filled with `NA` for those rows where there was no prior information (i.e. the first dataset):


```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->
### `fill()` {.unnumbered}

In this case, `Year` is a useful variable to include, particularly if we want to explore trends over time. Therefore, we use `fill()` to *fill* in those empty cells, by specifying the column to fill and the direction (in this case **up**):

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Alternatively, we can rearrange the data so that we would need to fill in a downward direction:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

We now have a useful dataset for plotting:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

But less useful for presenting in a table, so let's practice converting this long, untidy dataframe into a wider, tidy dataframe:

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

N.B. In this case, we had to specify to only include the three variables `Facility`, `Year`, and `Cases` as the additional variable `Measurement` would interfere with the creation of the table:

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Resources  

Here is a helpful [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)

