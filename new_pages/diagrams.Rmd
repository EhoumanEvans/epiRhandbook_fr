
# Diagrammes et graphiques {#diagrams}  



``{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(ici::here("images", "flow_chart.png"))
knitr::include_graphics(ici::ici("images", "sankey_diagram.png"))
```


Cette page couvre le code pour produire :  

* Des diagrammes de flux en utilisant **DiagrammemeR** et le langage DOT.  
* Diagrammes Alluvial/Sankey  
* Des chronologies d'événements  

* DAGs (Directed Acyclic Graphs) -->
<!-- * Graphiques de GANTT -->


<!-- ======================================================= -->
## Préparation { }

### Chargement des paquets {.unnumbered}  

Ce chunk de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *et* le charge pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [R basics] pour plus d'informations sur les paquets R.  

```{r}
pacman::p_load(
  DiagrammeR, # pour les diagrammes de flux
  networkD3, # pour les diagrammes alluviaux/Sankey
  tidyverse) # gestion et visualisation des données
```

### Importer des données {.unnumbered}  

La plupart du contenu de cette page ne nécessite pas de jeu de données. Cependant, dans la section sur le diagramme de Sankey, nous utiliserons la liste de cas d'une simulation d'épidémie d'Ebola. Si vous souhaitez suivre cette partie, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la liste de cas "propre"</a> (en tant que fichier .rds). Importez les données avec la fonction `import()` du paquet **rio** (elle gère de nombreux types de fichiers comme .xlsx, .csv, .rds - voir la page [Importation et exportation] pour plus de détails).  

``{r, echo=F}
# Importez la liste de diffusion dans R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Importez la liste de cas
linelist <- import("linelist_cleaned.rds")
```

Les 50 premières lignes de la linelist sont affichées ci-dessous.

``{r, message=FALSE, echo=F}
# affiche les données de la liste de diffusion sous forme de tableau
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space : nowrap' )
```



<!-- ======================================================= -->
## Diagrammes de flux { }

On peut utiliser le paquet R **DiagrammeR** pour créer des diagrammes/diagrammes de flux. Ils peuvent être statiques, ou s'ajuster quelque peu dynamiquement en fonction des changements dans un ensemble de données.  

**Outils  

La fonction `grViz()` est utilisée pour créer un diagramme "Graphviz". Cette fonction accepte une *chaîne de caractères en entrée contenant les instructions* pour réaliser le diagramme. Dans cette chaîne, les instructions sont écrites dans un langage différent, appelé [DOT](https://graphviz.org/doc/info/lang.html) - il est assez facile d'en apprendre les bases.  

**Structure de base**  

1) Ouvrez les instructions `grViz("`)  
2) Spécifiez la direction et le nom du graphe, et ouvrez les parenthèses, par exemple `digraph my_flow_chart {``
3) Déclaration du graphique (disposition, direction du rang)  
4) Déclaration des noeuds (crée les noeuds)
5) Instructions sur les arêtes (donne les liens entre les noeuds)  
6) Fermer les instructions `}")`  

### Exemples simples {.non numérotés} 

Vous trouverez ci-dessous deux exemples simples  

Un exemple très minimal :  

``{r out.width='50%'}
## Un tracé minimal
DiagrammeR::grViz("digraph {
  
graphique [layout = dot, rankdir = LR]

a
b
c

a -> b -> c
}")
```

Un exemple avec un contexte de santé publique peut-être un peu plus appliqué :  

```{r out.width='50%'}
grViz(" # Toutes les instructions se trouvent dans une grande chaîne de caractères
digraph surveillance_diagram { # 'digraph' signifie 'graphique directionnel', puis le nom du graphique 
  
  # déclaration du graphique
  #################
  graphe [layout = dot,
         rankdir = TB,
         overlap = true,
         fontsize = 10]
  
  # nouds
  #######
  noeud [shape = circle, # shape = circle
       fixedsize = true
       width = 1.3]               # largeur des cercles
  
  Primaire # noms des noeuds
  Secondaire
  Tertiaire

  # bords
  #######
  Primaire -> Secondaire [label = ' case transfer']
  Secondaire -> Tertiaire [label = ' case transfer']
}
")
```

### Syntaxe {.unnumbered}

**Syntaxe de base**  

Les noms de nouds, ou les déclarations d'arêtes, peuvent être séparés par des espaces, des points-virgules ou des nouvelles lignes.  

**Direction du rang**  

Un graphe peut être réorienté pour se déplacer de gauche à droite en ajustant l'argument `rankdir` dans la déclaration du graphe. Le défaut est TB (top-to-bottom), mais il peut être LR (left-to-right), RL, ou BT.  

**Noms de nouds**  

Les noms de noeuds peuvent être des mots simples, comme dans l'exemple simple ci-dessus. Pour utiliser des noms de plusieurs mots ou des caractères spéciaux (par exemple, parenthèses, tirets), placez le nom du noud entre guillemets simples (' '). Il peut être plus facile d'avoir un nom de noud court et d'attribuer un *label*, comme indiqué ci-dessous entre crochets [ ]. Si vous voulez avoir une nouvelle ligne dans le nom du noeud, vous devez le faire via une étiquette - utilisez `\n` dans l'étiquette du noeud entre guillemets simples, comme indiqué ci-dessous.  

**Sous-groupes**  
Dans les déclarations d'arêtes, des sous-groupes peuvent être créés de chaque côté de l'arête avec des crochets ({ }). L'arête s'applique alors à tous les nouds entre crochets - c'est un raccourci.  


**Mise en page**  

* dot (définir `rankdir` sur TB, LR, RL, BT, )
* Neato  
* twopi  
* circo  


**Nouds - attributs modifiables**  

* `label` (texte, entre guillemets simples si plusieurs mots)  
* `fillcolor` (plusieurs couleurs possibles)  
* `fontcolor` (plusieurs couleurs possibles)  
* `alpha` (transparence 0-1)  
* `shape` (ellipse, ovale, diamant, ouf, texte en clair, point, carré, triangle)  
* `style`  
* `côtés`  
* `périphéries`  
* Taille fixe (h x l)  
* `hauteur`  
* `largeur`  
* `distorsion`  
* `penwidth` (largeur de la bordure de la forme)  
* `x` (déplacement gauche/droite)  
* `y` (déplacement haut/bas)  
* `fontname`  
* `fontsize`  
* `icon`  


**Bords - attributs modifiables**  

* `taille de la flèche`  
* `arrowhead` (normal, box, crow, curve, diamond, dot, inv, none, tee, vee)  
* `arrowtail`  
* `dir` (direction, )  
* `style` (pointillé, ...)  
* `color`  
* `alpha`  
* `headport` (texte devant la tête de la flèche)  
* `tailport` (texte situé derrière la queue de flèche)  
* `fontname`  
* `fontsize`  
* `fontcolor` (couleur de la police)  
* `penwidth` (largeur de la flèche)  
* `minlen` (longueur minimale)

**Noms de couleurs** : valeurs hexadécimales ou noms de couleurs 'X11', voir [ici pour les détails sur X11](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html) 


### Exemples complexes {.unnumbered}

L'exemple ci-dessous développe le diagramme de surveillance, en ajoutant des noms de noeuds complexes, des arêtes groupées, des couleurs et un style.


```
DiagrammeR::grViz(" # Toutes les instructions sont dans une grande chaîne de caractères
digraph surveillance_diagram { # 'digraph' signifie 'graphique directionnel', puis le nom du graphique 
  
  # déclaration du graphique
  #################
  graphe [layout = dot,
         rankdir = TB, # disposition de haut en bas
         taille de police = 10]
  

  # nouds (cercles)
  #################
  node [shape = circle, # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primaire [label = 'Primaire'] 
  Secondaire [label = 'Secondaire'] 
  Tertiaire [label = 'Tertiaire'] 
  SC [label = "Surveillance\nCoordination",
             fontcolor = darkgreen] 
  
  # bords
  #######
  Primaire -> Secondaire [label = 'Transfert de cas',
                          fontcolor = rouge,
                          color = red]
  Secondaire -> Tertiaire [label = ' case transfer',
                          fontcolor = rouge,
                          couleur = rouge]
  
  # Bord groupé
  {Primaire Secondaire Tertiaire} -> SC [label = 'case reporting',
                                      fontcolor = vert foncé,
                                      couleur = vert foncé,
                                      style = pointillé]
}
")
```


```{r out.width='50%', echo=F}
DiagrammeR::grViz(" # Toutes les instructions se trouvent dans une grande chaîne de caractères
digraph surveillance_diagram { # 'digraph' signifie 'graphique directionnel', puis le nom du graphique 
  
  # déclaration du graphique
  #################
  graphe [layout = dot,
         rankdir = TB, # disposition de haut en bas
         taille de police = 10]
  

  # nouds (cercles)
  #################
  node [shape = circle, # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primaire [label = 'Primaire'] 
  Secondaire [label = 'Secondaire'] 
  Tertiaire [label = 'Tertiaire'] 
  SC [label = "Surveillance\nCoordination",
             fontcolor = darkgreen] 
  
  # bords
  #######
  Primaire -> Secondaire [label = 'transfert de cas',
                          fontcolor = rouge,
                          color = red]
  Secondaire -> Tertiaire [label = 'case transfer',
                          fontcolor = rouge,
                          couleur = rouge]
  
  # Bord groupé
  {Primaire Secondaire Tertiaire} -> SC [label = 'case reporting',
                                      fontcolor = vert foncé,
                                      couleur = vert foncé,
                                      style = pointillé]
}
")
```

**Groupements de sous-graphes  

Pour regrouper les nouds dans des clusters encadrés, placez-les dans le même sous-graphe nommé (`subgraph name {}`). Pour que chaque sous-graphe soit identifié dans une boîte de délimitation, commencez le nom du sous-graphe par "cluster", comme le montrent les 4 boîtes ci-dessous.  

```
DiagrammeR::grViz(" # Toutes les instructions sont dans une grande chaîne de caractères
digraph surveillance_diagram { # 'digraph' signifie 'graphique directionnel', puis le nom du graphique 
  
  # déclaration du graphique
  #################
  graphe [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # nouds (cercles)
  #################
  node [shape = circle, # shape = circle
       fixedsize = true
       width = 1.3]                      # largeur des cercles
  
  sous-graphe cluster_passive {
    Primaire [label = 'Primaire'] 
    Secondaire [label = 'Secondaire\nFacility'] 
    Tertiaire [label = 'Tertiaire'] 
    SC [label = "Surveillance\nCoordination",
               fontcolor = darkgreen] 
  }
  
  # nouds (cases)
  ###############
  node [shape = box, # node shape
        fontname = Helvetica]            # police du texte dans le noeud
  
  sous-graphe cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nRecherche active']
  }
  
  sous-graphe cluster_EBD {
    EBS [label = "Surveillance basée sur les événements (EBS)"] 
    Médias sociaux
    Radio
  }
  
  sous-graphe cluster_CBS {
    CBS [label = "Community-Based-Surveillance (CBS)"]
    RECOs
  }

  
  # edges
  #######
  {Primaire Secondaire Tertiaire} -> SC [label = 'déclaration des cas']

  Primaire -> Secondaire [label = 'transfert de cas',
                          fontcolor = rouge]
  Secondaire -> Tertiaire [label = 'case transfer',
                          fontcolor = rouge]
  
  HCF_active -> Active
  
  {Radio 'médias sociaux' -> EBS
  
  RECOs -> CBS
}
")

```


```{r out.width='120%', echo=F}
DiagrammeR::grViz(" # Toutes les instructions se trouvent dans une grande chaîne de caractères
digraph surveillance_diagram { # 'digraph' signifie 'graphique directionnel', puis le nom du graphique 
  
  # déclaration du graphique
  #################
  graphe [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # nouds (cercles)
  #################
  node [shape = circle, # shape = circle
       fixedsize = true
       width = 1.3]                      # largeur des cercles
  
  sous-graphe cluster_passive {
    Primaire [label = 'Primaire'] 
    Secondaire [label = 'Secondaire\nFacility'] 
    Tertiaire [label = 'Tertiaire'] 
    SC [label = "Surveillance\nCoordination",
               fontcolor = darkgreen] 
  }
  
  # nouds (cases)
  ###############
  node [shape = box, # node shape
        fontname = Helvetica]            # police du texte dans le noeud
  
  sous-graphe cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nRecherche active']
  }
  
  sous-graphe cluster_EBD {
    EBS [label = "Surveillance basée sur les événements (EBS)"] 
    Médias sociaux
    Radio
  }
  
  sous-graphe cluster_CBS {
    CBS [label = "Community-Based-Surveillance (CBS)"]
    RECOs
  }

  
  # edges
  #######
  {Primaire Secondaire Tertiaire} -> SC [label = 'déclaration des cas']

  Primaire -> Secondaire [label = 'transfert de cas',
                          fontcolor = rouge]
  Secondaire -> Tertiaire [label = 'case transfer',
                          fontcolor = rouge]
  
  HCF_active -> Active
  
  {Radio 'médias sociaux' -> EBS
  
  RECOs -> CBS
}
")

```


**Formes des nouds  

L'exemple ci-dessous, emprunté à [ce tutoriel] (http://rich-iannone.github.io/DiagrammeR/), montre les formes de nouds appliquées et une abréviation pour les connexions de bords en série.  

```{r out.width='75%'}
DiagrammeR::grViz("digraph {

graph [layout = dot, rankdir = LR]

# définir les styles globaux des noeuds. Nous pouvons les remplacer dans la boîte si nous le souhaitons.
node [shape = rectangle, style = filled, fillcolor = Linen]

data1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]
data2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]
process [label = 'Process \n Data']
statistical [label = "Statistical \n Analysis"] (Analyse statistique)
results [label= 'Results']

# définitions des bords avec les ID des nouds
{données1 données2} -> processus -> statistique -> résultats
}")
```


### Sorties {.non numérotées}

Comment gérer et sauvegarder les sorties  

* Les résultats apparaîtront dans le volet de visualisation de RStudio, par défaut dans le coin inférieur droit, à côté de Files, Plots, Packages et Help.  
* Pour exporter, vous pouvez "Enregistrer en tant qu'image" ou "Copier dans le presse-papiers" à partir de la visionneuse. Le graphique s'ajustera à la taille spécifiée.  




### Figures paramétrées {.unnumbered} 

Voici une citation de ce tutoriel : https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/  

"Figures paramétrées : L'un des grands avantages de la conception de figures dans R est que nous sommes en mesure de connecter les figures directement à notre analyse en lisant les valeurs R directement dans nos organigrammes. Par exemple, supposons que vous ayez créé un processus de filtrage qui supprime les valeurs après chaque étape d'un processus, vous pouvez avoir une figure montrant le nombre de valeurs restantes dans l'ensemble de données après chaque étape de votre processus. Pour ce faire, vous pouvez utiliser le symbole @@X directement dans la figure, puis y faire référence dans le pied de page du graphique en utilisant [X] :, où X est un indice numérique unique."  

Nous vous encourageons à revoir ce tutoriel si le paramétrage est quelque chose qui vous intéresse.  


<br />Et ci-dessous, vous trouverez un exemple de code tiré de ce tutoriel. -->

<!-- ``{r, eval=F} -->
<!-- # Définir quelques exemples de données -->
<!-- data <- list(a=1000, b=800, c=600, d=400) -->


<!-- DiagrammeR::grViz(" -->
<!-- digraphe graph2 { -->

<!-- graphe [disposition = point] -->

<!-- # définitions de nouds avec texte d'étiquette substitué -->
<!-- noeud [forme = rectangle, largeur = 4, couleur de remplissage = Biege] -->
<!-- a [label = '@@1'] -->
<!-- b [label = '@@2'] -->
<!-- c [label = '@@3'] --> <!-- c [label = '@@3'] -->
<!-- d [label = '@@4'] --> <!-- d [label = '@@4'] -->

<!-- a -> b -> c -> d -->

<!-- } -->

<!-- [1] : paste0('Données brutes (n = ', data$a, ')') -->
<!-- [2] : paste0('Suppression des erreurs (n = ', data$b, ')') -->
<!-- [3] : paste0('Identifier les clients potentiels (n = ', data$c, ')') -->
<!-- [4] : paste0('Sélectionner les principales priorités (n = ', data$d, ')') -->
<!-- ") -->

<!-- ``` -->



<!-- ### Diagramme CONSORT {.non numéroté} -->

<!-- CETTE SECTION EST EN CONSTRUCTION -->

<!-- https://scriptsandstatistics.wordpress.com/2017/12/22/how-to-draw-a-consort-flow-diagram-using-r-and-graphviz/ -->

<!-- La note ci-dessus est périmée via DiagrammeR -->




<!-- ======================================================= -->
## Diagrammes Alluvial/Sankey { }

### Chargement des paquets {.unnumbered}  

Ce morceau de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *et* le charge pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [R basics] pour plus d'informations sur les paquets R.  

Nous chargeons le paquet **networkD3** pour produire le diagramme, et aussi **tidyverse** pour les étapes de préparation des données.  

```{r}
pacman::p_load(
  réseauD3,
  tidyverse)
```

### Tracé à partir d'un ensemble de données {.unnumbered} 

Tracer les connexions dans un jeu de données. Nous démontrons ci-dessous l'utilisation de ce package sur le cas `linelist`. Voici un [tutoriel en ligne] (https://www.r-graph-gallery.com/321-introduction-to-interactive-sankey-diagram-2.html).    

Nous commençons par obtenir le nombre de cas pour chaque combinaison unique de catégorie d'âge et d'hôpital. Pour plus de clarté, nous avons supprimé les valeurs dont la catégorie d'âge est manquante. Nous renommons également les colonnes `hospital` et `age_cat` en `source` et `target` respectivement. Ce seront les deux côtés du diagramme alluvial.  

```{r}
# comptage par hôpital et par catégorie d'âge
liens <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hôpital, age_cat) %>% 
  rename(source = hôpital,
         cible = age_cat)
```

L'ensemble de données ressemble maintenant à ceci :  

``{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space : nowrap')
```


Maintenant, nous créons un cadre de données de tous les noeuds du diagramme, sous la colonne `name`. Il s'agit de toutes les valeurs de `hospital` et `age_cat`. Notez que nous nous assurons qu'elles sont toutes des caractères de classe avant de les combiner. et ajustons les colonnes ID pour qu'elles soient des nombres au lieu d'étiquettes :  

```{r}
# Les noms uniques des noeuds
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

nodes # print
```
Nous éditons le cadre de données `links`, que nous avons créé ci-dessus avec `count()`. Nous ajoutons deux colonnes numériques `IDsource` et `IDtarget` qui reflèteront/créeront réellement les liens entre les noeuds. Ces colonnes contiendront les numéros de rown (position) des noeuds source et cible. On soustrait 1 pour que ces numéros de position commencent à 0 (et non à 1).  

```{r}
# correspond aux nombres, pas aux noms
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
```

Le jeu de données des liens ressemble maintenant à ceci :  

``{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space : nowrap')
```

Tracez maintenant le diagramme de Sankey avec `sankeyNetwork()`. Vous pouvez en savoir plus sur chaque argument en exécutant `?sankeyNetwork` dans la console. Notez qu'à moins que vous ne définissiez `iterations = 0`, l'ordre de vos noeuds peut ne pas être celui attendu. 


```{r}

# plot
######
p <- sankeyNetwork(
  Liens = liens,
  Nouds = nouds,
  Source = "IDsource",
  Cible = "IDtarget",
  Valeur = "n",
  NodeID = "nom",
  unités = "TWh",
  fontSize = 12,
  nodeWidth = 30,
  itérations = 0) # Assurez-vous que l'ordre des noeuds est celui des données.
p
```



Voici un exemple où le résultat du patient est également inclus. Notez que dans l'étape de préparation des données, nous devons calculer le nombre de cas entre l'âge et l'hôpital, et séparément entre l'hôpital et le résultat - puis lier tous ces comptes ensemble avec `bind_rows()``.  

```{r}
# Nombre de cas par hôpital et par catégorie d'âge
age_hosp_links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hôpital, age_cat) %>%
  count(hôpital, age_cat) %>% 
  rename(source = age_cat, # re-name
         cible = hôpital)

hosp_out_links <- linelist %>% 
    drop_na(âge_cat) %>% 
    select(hôpital, résultat) %>% 
    count(hôpital, résultat) %>% 
    rename(source = hospital, # re-name
           cible = résultat)

# combiner les liens
liens <- bind_rows(age_hosp_links, hosp_out_links)

# Les noms uniques des noeuds
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

# Créer des numéros d'identification
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1

# tracer
######
p <- sankeyNetwork(Links = links,
                   Nouds = nouds,
                   Source = "IDsource",
                   Cible = "IDtarget",
                   Valeur = "n",
                   NodeID = "nom",
                   unités = "TWh",
                   fontSize = 12,
                   nodeWidth = 30,
                   itérations = 0)
p

```


https://www.displayr.com/sankey-diagrams-r/



<!-- ======================================================= -->
## Chronologie des événements { }

Pour faire une timeline montrant des événements spécifiques, vous pouvez utiliser le paquet `vistime`.

Voir cette [vignette](https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning)

```{r}
# charger le paquet
pacman::p_load(vistime, # créer la ligne de temps
               plotly # pour la visualisation interactive
               )
```

``{r, echo=F}
# référence : https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning

data <- read.csv(text="événement, groupe, début, fin, couleur
                       Événement 1, Groupe A,2020-01-22,2020-01-22, #90caf9
                       Événement 1, Groupe B,2020-01-23,2020-01-23, #90caf9
                       Evénement 1, Groupe C,2020-01-23,2020-01-23, #1565c0
                       Événement 1, Groupe D,2020-01-25,2020-01-25, #f44336
                       Manifestation 1, Groupe E,2020-01-25,2020-01-25, #90caf9
                       Événement 1, Groupe F,2020-01-26,2020-01-26, #8d6e63
                       Événement 1, Groupe G,2020-01-27,2020-01-27, #1565c0
                       Manifestation 1, Groupe H,2020-01-27,2020-01-27, #90caf9
                       Événement 1, Groupe I,2020-01-27,2020-01-27,#90a4ae
                       Épreuve 2, Groupe A,2020-01-28,2020-01-28,#fc8d62
                       Épreuve 2, Groupe C,2020-01-28,2020-01-28,#6a3d9a
                       Événement 2, Groupe J,2020-01-28,2020-01-28,#90caf9
                       Événement 2, Groupe J,2020-01-28,2020-01-28, #fc8d62
                       Événement 2, Groupe J,2020-01-28,2020-01-28, #1565c0
")
```

Voici l'ensemble de données d'événements avec lequel nous commençons :  

``{r message=FALSE, echo=F}
DT::datatable(data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space : nowrap')
```



```{r}
p <- vistime(data) # appliquer vistime

library(plotly)

# étape 1 : transformation en liste
pp <- plotly_build(p)

# étape 2 : taille des marqueurs
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "markers") pp$x$data[[i]]$marker$size <- 10
}

# étape 3 : taille du texte
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textfont$size <- 10
}


# étape 4 : position du texte
for(i in 1:length(pp$x$data)){
  si(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textposition <- "right"
}

#print
pp

```



<!-- ======================================================= -->
## DAGs { }

Vous pouvez construire un DAG manuellement en utilisant le paquet **DiagammeR** et le langage DOT comme décrit ci-dessus.  

Alternativement, il existe des paquets comme **ggdag** et **daggity**.

[Introduction aux DAGs - vignette ggdag](https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html)   

[Inférence causale avec les dags dans R](https://www.r-bloggers.com/2019/08/causal-inference-with-dags-in-r/#:~:text=En%20a%20DAG%20tout%20le,pour%20 dessiner%20et%20analyser%20DAGs.)  





<!-- ======================================================= -->
## Ressources { }



Une grande partie de ce qui précède concernant le langage DOT est adaptée du tutoriel [sur ce site](https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/).  

Un autre [tutoriel sur DiagammeR] (http://rich-iannone.github.io/DiagrammeR/) plus approfondi.

Cette page sur les [diagrammes de Sankey] (https://www.displayr.com/sankey-diagrams-r/)
)  

