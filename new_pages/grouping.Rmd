
# Travailler sur des données groupées {#grouping_data}  


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```

Ce chapitre explique comment grouper et agréger des données lors une analyse descriptive. Elle utilise des fonctions du méta-paquet  **tidyverse** pour des fonctions communes et faciles à utiliser. 


Grouper les données est une étape essentielle de la gestion et de l'analyse de données. Par exemple, il est souvent nécessaire de créer des résumés statistiques ou des figures par "groupe". Les fonctions du paquet **dplyr** (qui fait partie de **tidyverse**) facilitent le groupement et les opérations ultérieures.  


Ce chapitre aborde les sujets suivants :  

* Grouper les données avec la fonction `group_by()`.  
* Dé-grouper des données  
* Résumer les données groupées avec des statistiques (`summarise()`)  
* La différence entre `count()` et `tally()`.  
* `arrange()` appliqué aux données groupées  
* `filter()` appliqué à des données groupées  
* `mutate()` appliqué à des données groupées  
* `select()` appliqué à des données groupées  
* La commande **base** R `aggregate()`, qui est une alternative aux fonctions de **dplyr**.  





<!-- ======================================================= -->
## Étapes préliminaires {  }

### Importation des paquets {.unnumbered}  

Ces lignes de code chargent les paquets nécessaires aux analyses. Dans ce guide, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *puis* l'importe pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [bases de R](#rbasics) pour plus d'informations sur les paquets R.  

```{r}
pacman::p_load(
  rio,       # importaion des fichiers
  here,      # gestion des chemins d'accès
  tidyverse, # gestion des données + graphiques (inclus dplyr)
  janitor)   # Ajout de totaux aux lignes et colonnes
```




### Importation des données {.unnumbered}

Dans ce chapitre, nous utiliserons un jeu de données fictif d'une épidémie d'Ebola. Pour reproduire les étapes, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la liste de diffusion "nettoyée"</a> (sous forme de fichier .rds). Le jeu de données est importé à l'aide de la fonction `import()` du paquet **rio**. voir la page [Importation et exportation des données](import_export) pour plus de détails).  


```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Les premières cinquante lignes de la `linelist` :  

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Grouper des données {  }
     
La fonction `group_by()` de **dplyr** permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Chaque valeur unique (ou combinaison de valeurs unique, dans le cas où plusieurs colonnes sont spécifiées) constitue un groupe. Une fois groupées, de nombreuses fonctions utilisées pour le nettoyage ou des analyses descriptives seront appliquées à chaque groupe.

Par exemple, le code ci-dessous groupe la `linelist` en fonction des valeurs uniques de la colonne `outcome`. La ou les colonnes de selon lesquelles grouper les données sont placées entre parenthèses dans la fonction `group_by()`. La fonction génère un nouveau tableau de données, que nous nommons `ll_by_outcome`.  


```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

**Notez que les données elles mêmes n'ont pas été modifiées** après avoir exécuté `group_by()`. Le fait que le dataframe soit "groupé" se verra lorsqu'une autre fonction du paquet **dplyr** tel que `mutate()`, `summarise()`, ou `arrange()` soit appliqué sur le dataframe "groupé".  

Vous pouvez cependant savoir qu'un dataframe est groupé en l'affichant / l'imprimant dans la console. Vous verrez alors qu'il a été transformé en un [objet de classe `tibble`](https://tibble.tidyverse.org/) qui, lorsqu'il est affiché, indique les groupements présents et le nombre de groupes qu'il y a juste au-dessus de la ligne d'en-tête.  


```{r}
# print to see which groups are active
ll_by_outcome
```


### Groupes distincts {.unnumbered}  

**Les groupes sont basés sur les combinaisons uniques de valeurs dans les colonnes de groupement**. 

Pour afficher les groupes *et le nombre de lignes de chaque groupe*, passez les données groupées à la fonction `tally()`. Pour afficher les groupes présents sans nombre de lignes, passez les données à la fonction `group_keys()`.  

Dans l'exemple ci-dessous, il y a **trois** valeurs uniques dans la colonne de groupement `outcome` : "Death", "Recover", et "NA". Vous voyez qu'il y avait ` nrow(linelist %>% filter(outcome == "Death"))` morts, ` nrow(linelist %>% filter(outcome == "Recover"))` guéris, et ` nrow(linelist %>% filter(is.na(outcome)))` individus sans information renseignée.  


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```

Vous pouvez regrouper par plus d'une colonne. Ci-dessous, nous groupons le dataframe par `outcome` et `gender`, puis comptons le nombre de lignes dans chaque groupe. Chaque combinaison unique de `outcome` et `gender` est crée un groupe différent, y compris les valeurs manquantes pour chaque colonne.  


```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### Nouvelle colonne {.unnumbered} 

Vous pouvez également grouper selon une colonne crée *directement dans* la fonction `group_by()`. Cela revient à appeler `mutate()` avant le `group_by()`. Cela peut être intéressant pour créer de petites tables descriptives rapidement, mais dans d'autres cas, il sera plus lisible de créer la nouvelle colonne avec la fonction `mutate()` avant de passer le tableau à `group_by()`.  


```{r}
# grouper les données sur la base d'une colonne crée dans la commande group_by()
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```


### Grouper selon plus ou moins de colonnes {.unnumbered}  

Par défaut, si vous exécutez `group_by()` sur des données déjà groupées, les anciens groupes seront supprimés et le ou les nouveaux groupes s'appliqueront. Si vous voulez ajouter de nouveaux groupes à ceux qui existent déjà, incluez l'argument `.add = TRUE`.  

````{r, eval=F}
# Grouper par  outcome
by_outcome <- linelist %>% 
  group_by(outcome)

# Ajouter gender aux définition de groupe (grouper par une combinaison
# de gender et outcome)
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```


### Garder tous les groupes {.unnumbered} 


Si vous groupez les données sur la base d'une colonne de type "facteur", il se peut que des niveaux du facteur ne soient pas présents dans le jeu de données actuel. Dans ce cas, ces niveaux non présents seront abandonnés par défaut et donc n'apparaitront pas dans les groupes. Pour prendre en compte tous les niveaux de facteur, y compris lorsqu'ils ne contiennent pas de données, utilisez l'argument `.drop = FALSE` dans votre commande `group_by()`.  

## Dégrouper les données

Les données qui ont été groupées le resteront jusqu'à ce qu'elles soient spécifiquement dégroupées grâce à la fonction `ungroup()`. 
Attention à ne pas oublier de dégrouper les données avant de passer aux étapes qui necessitent le jeu de données complet et non groupé.  

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

On peut également dégrouper seulement certaines colonnes, en passant le nom e la colonne à `ungroup()`.   

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # dégroupe par gender, mais garde le groupement par outcome
```


<span style="color: black;">**_NOTE:_** Le verbe `count()` dégroupe automatiquement les données après avoir compté les lignes.</span>



## Résumer les données par groupe {#group_summarise} 

Voir la section **dplyr** du chapitre sur les [Tableaux descriptifs](#descriptive_tables) pour une explication détaillée sur comment produire des tableaux récapitulatifs à l'aide de la fonction `summarise()`. Ici, nous décrivons le comportement de `summarise()` lorsque la fonction est appliquée à des données groupées.  

La fonction de **dplyr** `summarise()` (ou `summarize()`) prend un dataframe en entrée et le convertit en un *nouveau dataframe* contenant des statistiques de synthèse définies par l'utilisateur. Sur un tableau non groupé, le calcul de synthèse est effectuée sur toutes les lignes. Sur un tableau groupé, le calcul est effectué *pour chaque groupe*.  


Plus précisement, la syntaxe de la fonction `summarise()` est du type :
"NOM_NOUVELLE_COLONNE = fonction résumé d'une ou plusieurs colonnes des données source". Dans la fonction statistique, indiquez la colonne à traiter et tout argument pertinent (par exemple, `na.rm = TRUE`). Les fonctions régulièrement utilisées incluent par exemple `mean()`, `min()`, `max()`, `median()`, ou `sd()`, mais on peut également utiliser `sum()` pour compter le nombre de lignes qui répondent à un critère logique (avec des doubles égaux `==`).    

Vous trouverez ci-dessous un exemple de `summarise()` appliqué *sur des données non groupées* : les statistiques retournées sont produites à partir de l'ensemble des données.     


```{r}
# statistiques résumées appliquéesur le jeu de données complet
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm = T),
    max_age  = max(age_years,  na.rm = T),
    min_age  = min(age_years,  na.rm = T),
    n_males  = sum(gender == "m", na.rm = T))
```

Maintenant, la même commande est appliquée sur la linelist groupée, ce qui génère les résumés statistique pour chaque groupe. Notez que les colonnes utilisées pour définir les groupes sont gardées dans le tableau aggrégé généré par `summarise()`.      
```{r}
# statistiques résumées appliquéesur le jeu de données complet 
# mais groupé par outcome
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm = T),
    max_age  = max(age_years,  na.rm = T),
    min_age  = min(age_years,  na.rm = T),
    n_males  = sum(gender == "m", na.rm = T))
```

<span style="color: darkgreen;">**_Note:_** il est possible d'appeler la fonction en utilisant l'orthographe britanique et américaine : `summarise()` et `summarize()` sont équivalentes.</span>




## Counts and tallies  

`count()` and `tally()` provide similar functionality but are different. Read more about the distinction between `tally()` and `count()` [here](https://dplyr.tidyverse.org/reference/tally.html)    

### `tally()` {.unnumbered}  

`tally()` is shorthand for `summarise(n = n())`, and *does not* group data. Thus, to achieve grouped tallys it must follow a `group_by()` command. You can add `sort = TRUE` to see the largest groups first.    

```{r}
linelist %>% 
  tally()
```


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```


### `count()`  {.unnumbered}  

In contrast, `count()` does the following:  

1) applies `group_by()` on the specified column(s)  
2) applies `summarise()` and returns column `n` with the number of rows per group  
3) applies `ungroup()`  

```{r}
linelist %>% 
  count(outcome)
```

Just like with `group_by()` you can create a new column within the `count()` command:  

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```


`count()` can be called multiple times, with the functionality "rolling up". For example, to summarise the number of hospitals present for each gender, run the following. Note, the name of the final column is changed from default "n" for clarity (with `name  = `).  

```{r}
linelist %>% 
  # produce counts by unique outcome-gender groups
  count(gender, hospital) %>% 
  # gather rows by gender (3) and count number of hospitals per gender (6)
  count(gender, name = "hospitals per gender" ) 
```


### Add counts {.unnumbered}  

In contrast to `count()` and `summarise()`, you can use `add_count()` to *add* a new column `n` with the counts of rows per group *while retaining all the other data frame columns*.   

This means that a group's count number, in the new column `n`, will be printed in each row of the group. For demonstration purposes, we add this column and then re-arrange the columns for easier viewing. See the section below on [filter on group size](#group_filter_grp_size) for another example.  


```{r}
linelist %>% 
  as_tibble() %>%                   # convert to tibble for nicer printing 
  add_count(hospital) %>%           # add column n with counts by hospital
  select(hospital, n, everything()) # re-arrange for demo purposes
```



### Add totals {.unnumbered} 

To easily add total *sum* rows or columns after using `tally()` or `count()`, see the **janitor** section of the [Descriptive tables](#tbl_janitor) page. This package offers functions like `adorn_totals()` and `adorn_percentages()` to add totals and convert to show percentages. Below is a brief example:  

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts of two columns
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions with column denominator
  adorn_pct_formatting() %>%                  # convert proportions to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```


To add more complex totals rows that involve summary statistics other than *sums*, see [this section of the Descriptive Tables page](#tbl_dplyr_totals).  



## Grouping by date  

When grouping data by date, you must have (or create) a column for the date unit of interest - for example "day", "epiweek", "month", etc. You can make this column using `floor_date()` from **lubridate**, as explained in the [Epidemiological weeks section](#dates_epi_wks) of the [Working with dates] page. Once you have this column, you can use `count()` from **dplyr** to group the rows by those unique date values and achieve aggregate counts. 

One additional step common for date situations, is to "fill-in" any dates in the sequence that are not present in the data. Use `complete()` from **tidyr** so that the aggregated date series is *complete* including *all possible date units* within the range. Without this step, a week with no cases reported might not appear in your data!  

Within `complete()` you *re-define* your date column as a *sequence* of dates `seq.Date()` from the minimum to the maximum  - thus the dates are expanded. By default, the case count values in any new "expanded" rows will be `NA`. You can set them to 0 using the `fill = ` argument of `complete()`, which expects a named list (if your counts column is named `n`, provide `fill = list(n = 0)`. See `?complete` for details and the [Working with dates](#dates_epi_wks) page for an example.  



### Linelist cases into days  {.unnumbered}  

Here is an example of grouping cases into days *without* using `complete()`. Note the first rows skip over dates with no cases.  

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # remove that were missing date_onset
  count(date_onset)              # count number of rows per unique date
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Below we add the `complete()` command to ensure every day in the range is represented.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove case missing date_onset
  count(date_onset) %>%                   # count number of rows per unique date
  complete(                               # ensure all days appear even if no cases
    date_onset = seq.Date(                # re-define date colume as daily sequence of dates
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into weeks {.unnumbered}  


The same principle can be applied for weeks. First create a new column that is the week of the case using `floor_date()` with `unit = "week"`. Then, use `count()` as above to achieve weekly case counts. Finish with `complete()` to ensure that all weeks are represented, even if they contain no cases.

```{r}
# Make dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove cases missing date_onset
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # new column of week of onset
  count(week) %>%                         # group data by week and count rows per group
  complete(                               # ensure all days appear even if no cases
    week = seq.Date(                      # re-define date colume as daily sequence of dates
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

Here are the first 50 rows of the resulting data frame:  

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into months {.unnumbered}

To aggregate cases into months, again use `floor_date()` from the **lubridate** package, but with the argument `unit = "months"`. This rounds each date down to the 1st of its month. The output will be class Date. Note that in the `complete()` step we also use `by = "months"`.  


```{r}
# Make dataset of monthly case counts
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # new column, 1st of month of onset
  count(month) %>%                          # count cases by month
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # include all months with no cases reported
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Daily counts into weeks {.unnumbered}

To aggregate daily counts into weekly counts, use `floor_date()` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per week.



#### Daily counts into months {.unnumbered}

To aggregate daily counts into months counts, use `floor_date()` with `unit = "month"` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per month.  




## Arranging grouped data

Using the **dplyr** verb `arrange()` to order the rows in a data frame behaves the same when the data are grouped, *unless* you set the argument `.by_group =TRUE`. In this case the rows are ordered first by the grouping columns and then by any other columns you specify to `arrange()`.   



## Filter on grouped data

### `filter()` {.unnumbered}

When applied in conjunction with functions that evaluate the data frame (like `max()`, `min()`, `mean()`), these functions will now be applied to the groups. For example, if you want to filter and keep rows where patients are above the median age, this will now apply per group - filtering to keep rows above the *group's* median age. 




### Slice rows per group {.unnumbered} 

The **dplyr** function `slice()`, which [filters rows based on their position](https://dplyr.tidyverse.org/reference/slice.html) in the data, can also be applied per group. Remember to account for sorting the data within each group to get the desired "slice".  

For example, to retrieve only the latest 5 admissions from each hospital:  

1) Group the linelist by column `hospital`  
2) Arrange the records from latest to earliest `date_hospitalisation` *within each hospital group*  
3) Slice to retrieve the first 5 rows from each hospital  

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # for display
  select(case_id, hospital, date_hospitalisation)  # for display
```

`slice_head()` - selects n rows from the top  
`slice_tail()` - selects n rows from the end  
`slice_sample()` - randomly selects n rows  
`slice_min()` - selects n rows with highest values in `order_by = ` column, use `with_ties = TRUE` to keep ties  
`slice_max()` - selects n rows with lowest values in `order_by = ` column, use `with_ties = TRUE` to keep ties  

See the [De-duplication] page for more examples and detail on `slice()`.  




### Filter on group size {#group_filter_grp_size .unnumbered} 

The function `add_count()` adds a column `n` to the original data giving the number of rows in that row's group. 

Shown below, `add_count()` is applied to the column `hospital`, so the values in the new column `n` reflect the number of rows in that row's hospital group. Note how values in column `n` are repeated. In the example below, the column name `n` could be changed using `name = ` within `add_count()`. For demonstration purposes we re-arrange the columns with `select()`.  


```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # add "number of rows admitted to same hospital as this row" 
  select(hospital, n, everything())
```

It then becomes easy to filter for case rows who were hospitalized at a "small" hospital, say, a hospital that admitted fewer than 500 patients:  

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```





## Mutate on grouped data  

To retain all columns and rows (not summarise) and *add a new column containing group statistics*, use `mutate()` after `group_by()` instead of `summarise()`. 

This is useful if you want group statistics in the original dataset *with all other columns present* - e.g. for calculations that compare one row to its group.  

For example, this code below calculates the difference between a row's delay-to-admission and the median delay for their hospital. The steps are:  

1) Group the data by hospital  
2) Use the column `days_onset_hosp` (delay to hospitalisation) to create a new column containing the mean delay at the hospital of *that row*  
3) Calculate the difference between the two columns  

We `select()` only certain columns to display, for demonstration purposes.  

```{r}
linelist %>% 
  # group data by hospital (no change to linelist yet)
  group_by(hospital) %>% 
  
  # new columns
  mutate(
    # mean days to admission per hospital (rounded to 1 decimal)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # select certain rows only - for demonstration/viewing purposes
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```



## Select on grouped data  

The verb `select()` works on grouped data, but the grouping columns are always included (even if not mentioned in `select()`). If you do not want these grouping columns, use `ungroup()` first.  










<!-- ======================================================= -->
## Resources {  }

Here are some useful resources for more information:  

You can perform any summary function on grouped data; see the [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)  

The Data Carpentry page on [**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html)  
The **tidyverse** reference pages on [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) and [grouping](https://dplyr.tidyverse.org/articles/grouping.html)  

This page on [Data manipulation](https://itsalocke.com/files/DataManipulationinR.pdf)  

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)  






