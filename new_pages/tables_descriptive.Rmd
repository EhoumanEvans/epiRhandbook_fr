# Tableaux descriptifs {#descriptive_tables}

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Cette page montre l'utilisation de **janitor**, **dplyr**, **gtsummary**, **rstatix** et **extension/package R base** pour résumer des données et créer des tableaux avec des statistiques descriptives.

*Cette page explique comment* créer\* les tableaux de base, tandis que la page \[Tableaux pour la présentation\] explique comment les mettre en forme et les imprimer.

Chacun de ces packages présente des avantages et des inconvénients dans les domaines de la simplicité du code, de l'accessibilité des sorties, de la qualité des sorties imprimées. Utilisez cette page pour décider quelle approche convient à votre scénario.

Plusieurs choix s'offrent à vous lorsque vous produisez des tableaux de synthèse et des tableaux croisés. Parmi les facteurs à prendre en compte, la simplicité du code, les possibilités de personnalisation, la sortie que vous souhaitez obtenir ( affichée sur la console R, en tant que tableau de données, ou en tant que " bonne " image .png/.jpeg/.html), et la facilité de traitement ultérieur. Tenez compte des points ci-dessous pour choisir l'outil adapté à votre situation.

-   Utilisez la fonction `tabyl()` de **janitor** pour produire et " personnaliser " des tableaux et des tableaux croisés\

-   Utilisez la fonction `get_summary_stats()` de **rstatix** pour générer facilement des tableaux de données de synthèse de statistiques numériques pour plusieurs colonnes et/ou groupes\

-   Utilisez les fonctions `summarise()` et `count()` de **dplyr** pour des statistiques plus complexes, des sorties de tableaux de données ordonnées ou la préparation de données pour `ggplot()`\

-   Utilisez la fonction `tbl_summary()` de **gtsummary** pour produire des tableaux détaillés prêts à être publiés\

-   Utilisez la fonction `table()` de **extension/package R base** si vous n'avez pas accès aux packages ci-dessus

<!-- ======================================================= -->

## Préparation

### Chargement des packages {.unnumbered}

Ce bloc de code montre le chargement des packages nécessaires pour les analyses. Dans ce manuel, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le package si nécessaire *et* le charge pour utilisation. Vous pouvez également charger les packages installés avec `library()` de **extension/package R base**. Voir la page sur \[R base\] pour plus d'informations sur les packages R.

```{r, warning=F, message=F}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  gtsummary,    # summary statistics and tests
  rstatix,      # summary statistics and statistical tests
  janitor,      # adding totals and percents to tables
  scales,       # easily convert proportions to percents  
  flextable     # converting tables to pretty images
  )
```

### Importer les données {.unnumbered}

Nous importons le jeu de données des cas d'une épidémie d'Ebola simulée. Si vous voulez suivre,<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la linelist " nettoyé ".</a>(as .rds file). Importez vos données avec la fonction `import()` du package **rio** (elle accepte de nombreux types de fichiers comme .xlsx, .rds, .csv - voir la page \[Importation et exportation\] pour plus de détails.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Explorer les données

### **skimr** package {.unnumbered}

En utilisant le package **skimr**, vous pouvez obtenir un aperçu détaillé et esthétique de chacune des variables de votre ensemble de données. Pour en savoir plus sur **skimr**, consultez sa [page github](https://github.com/ropensci/skimr).

Ci-dessous, la fonction `skim()` est appliquée à l'ensemble du tableau de données `linelist`. Un aperçu du tableau de données et un résumé de chaque colonne (par classe) est produit.

```{r eval=F}
## get information about each variable in a dataset 
skim(linelist)
```

```{r  echo=F}
# sparkline histograms not showing correctly, so avoiding them.
skim_without_charts(linelist)
```

Vous pouvez également utiliser la fonction `summary()`de **extension/package R base**, pour obtenir des informations sur un jeu de données entier, mais cette sortie peut être plus difficile à lire qu'en utilisant **skimr**. C'est pourquoi la sortie n'est pas montrée ci-dessous, afin de conserver de l'espace sur la page.

```{r, eval=F}
## get information about each column in a dataset 
summary(linelist)
```

### Statistiques sommaires {.unnumbered}

Vous pouvez utiliser les fonctions **extension/package R base** pour renvoyer des synthèses statistiques sur une colonne numérique. Vous pouvez retourner la plupart des synthèses statistiques utiles pour une colonne numérique en utilisant `summary()`, comme ci-dessous. Notez que le nom du tableau de données doit également être spécifié comme indiqué ci-dessous.

```{r}
summary(linelist$age_years)
```

Vous pouvez accéder à une partie spécifique et l'enregistrer avec les crochets d'indexation \[ \] :

```{r}
summary(linelist$age_years)[[2]]            # return only the 2nd element
# equivalent, alternative to above by element name
# summary(linelist$age_years)[["1st Qu."]]  
```

Vous pouvez renvoyer des statistiques individuelles avec des fonctions **extension/package R base** comme `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, et `range()`. Consultez la page \[Bases R\] pour obtenir une liste complète.

[***CAUTION:*** Si vos données contiennent des valeurs manquantes, R veut que vous le sachiez et retournera donc `NA`, sauf si vous spécifiez aux fonctions mathématiques ci-dessus que vous voulez que R ignore les valeurs manquantes, via l'argument `na.rm = TRUE`.]{style="color: orange;"}

Vous pouvez utiliser la fonction `get_summary_stats()` de **rstatix** pour retourner des synthèses statistiques *dans un format de tableau de données*. Cela peut être utile pour effectuer des opérations ultérieures ou des tracés sur les chiffres. Consultez la page \[Tests statistiques simples\] pour plus de détails sur le package **rstatix** et ses fonctions.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for
    type = "common")                    # summary stats to return

```

## **janitor** package {#tbl_janitor}

Les packages **janitor** offrent la fonction `tabyl()` pour produire des tableaux et des tableaux croisés, qui peuvent être " améliorés " ou modifiés avec des fonctions d'aide pour afficher des pourcentages, des proportions, des comptes, etc.

Ci-dessous, nous envoyons le tableau de données `linelist` aux fonctions **janitor** et nous affichons le résultat. Si vous le souhaitez, vous pouvez également enregistrer les tableaux résultants avec l'opérateur d'affectation `<-`.

### Simple tabyl {.unnumbered}

L'utilisation par défaut de `tabyl()` sur une colonne spécifique produit les valeurs uniques, les nombres, et les "pourcentages" par colonne ( proportion en fait). Les proportions peuvent avoir plusieurs chiffres. Vous pouvez ajuster le nombre de décimales avec `adorn_rounding()` comme décrit ci-dessous.

```{r}
linelist %>% tabyl(age_cat)
```

Comme vous pouvez le voir ci-dessus, s'il y a des valeurs manquantes, elles s'affichent dans une ligne étiquetée `<NA>`. Vous pouvez les supprimer avec `show_na = FALSE`. S'il n'y a pas de valeurs manquantes, cette ligne n'apparaîtra pas. S'il y a des valeurs manquantes, toutes les proportions sont données à la fois brutes (dénominateur incluant les comptes `NA`) et "valide" (dénominateur excluant les comptes `NA`).

Si la colonne est un facteur de classe et que seuls certains niveaux sont présents dans vos données, tous les niveaux apparaîtront quand même dans le tableau. Vous pouvez supprimer cette fonctionnalité en spécifiant `show_missing_levels = FALSE`. Pour en savoir plus, consultez la page \[Facteurs\].

### Tableau croisé {.unnumbered}

Les chiffres des tableaux croisés sont obtenus en ajoutant une ou plusieurs colonnes supplémentaires dans `tabyl()`. Notez que maintenant, seuls les chiffres sont retournés - les proportions et les pourcentages peuvent être ajoutés avec les étapes supplémentaires montrées ci-dessous.

```{r}
linelist %>% tabyl(age_cat, gender)
```

### "Habillage" du tabyl {#tbl_adorn .unnumbered}

Utilisez les fonctions "adorn" de **janitor** pour ajouter des totaux ou convertir en proportions, en pourcentages, ou ajuster l'affichage. Souvent, vous ferez passer le tabyle par plusieurs de ces fonctions.

+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Fonction                 | Résultat                                                                                                                                                                                                   |
+==========================+============================================================================================================================================================================================================+
| `adorn_totals()`         | Ajoute les totaux (`où =` " ligne ", " colonne ", ou " les deux "). Définissez `nom =` pour "Total".                                                                                                       |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_percentages()`    | Convertir les nombres en proportions, avec `denominateur =` " ligne ", " colonne ", ou " tout ".                                                                                                           |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_pct_formatting()` | Convertit les proportions en pourcentages. Spécifiez `digits =`. Supprimez le symbole "%" avec `affix_sign = FALSE`.                                                                                       |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_rounding()`       | Pour arrondir les proportions à des positions `digits =`. Pour arrondir les pourcentages, utilisez `adorn_pct_formatting()` with `digits =`.                                                               |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_ns()`             | Ajoutez des nombres à un tableau de proportions ou de pourcentages. Indiquez `position =` "arrière" pour montrer les nombres entre parenthèses, ou "avant" pour mettre les pourcentages entre parenthèses. |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_title()`          | Ajouter une chaîne via les arguments `row_name =` et/ou `col_name =`.                                                                                                                                      |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Faites attention à l'ordre dans lequel vous appliquez les fonctions ci-dessus. Voici quelques exemples.

Un simple tableau à sens unique avec des pourcentages au lieu des proportions par défaut.

```{r}
linelist %>%               # case linelist
  tabyl(age_cat) %>%       # tabulate counts and proportions by age category
  adorn_pct_formatting()   # convert proportions to percents
```

Un tableau croisé avec une ligne totale et des pourcentages de ligne.

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # counts by age and gender
  adorn_totals(where = "row") %>%             # add total row
  adorn_percentages(denominator = "row") %>%  # convert counts to proportions
  adorn_pct_formatting(digits = 1)            # convert proportions to percents
```

Un tableau croisé ajusté de façon à ce que les nombres et les pourcentages soient affichés.

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions
  adorn_pct_formatting() %>%                  # convert to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```

### Impression du tableau {.unnumbered}

Par défaut, le tableau s'affichera brute sur votre console R.

Vous pouvez également passer le tableau à **flextable** ou à un package similaire pour qu'il s'imprime comme une "jolie" image dans la visionneuse RStudio, qui peut être exportée en .png, .jpeg, .html, etc. Ce sujet est abordé à la page \[Tableaux pour la présentation\]. Notez que si vous imprimez de cette manière en utilisant `adorn_titles()`, vous devez spécifier `placement = "combined"`.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # this is necessary to print as image
  flextable::flextable() %>%    # convert to pretty image
  flextable::autofit()          # format to one line per row 

```

### Utiliser sur d'autres tables {.unnumbered}

Vous pouvez utiliser les fonctions `adorn_*()` de **janitor** sur d'autres tables, comme celles crées par `summarise()` et `count()` de **dplyr**, ou `table()` de **extension/package R base**. Il suffit de passer la table à la fonction **janitor** désirée. Par exemple :

```{r}
linelist %>% 
  count(hospital) %>%   # dplyr function
  adorn_totals()        # janitor function
```

### Enregistrer le tableau {.unnumbered}

Si vous convertissez le tableau en une " jolie " image avec un package comme **flextable**, vous pouvez l'enregistrer avec les fonctions de ce package - comme `save_as_html()`, `save_as_word()`, `save_as_ppt()`, et `save_as_image()` de **flextable** (comme discuté plus en détail dans la page \[Tableaux de présentation\]). Ci-dessous, le tableau est enregistré sous forme de document Word, dans lequel il peut être modifié manuellement.

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # convert to image
  flextable::autofit() %>%                       # ensure only one line per row
  flextable::save_as_docx(path = "tabyl.docx")   # save as Word document to filepath
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Statistiques {#janitor_age_out_stats .unnumbered}

Vous pouvez appliquer des tests statistiques sur les tableaux, comme `chisq.test()` ou `fisher.test()` du package **stats**, comme indiqué ci-dessous. Notez que les valeurs manquantes ne sont pas autorisées, elles sont donc exclues du tableau avec `show_na = FALSE`

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Consultez la page sur les \[Tests statistiques simples\] pour obtenir plus de code et de conseils sur les statistiques.

### Autres conseils {.unnumbered}

-   Incluez l'argument `na.rm = TRUE` pour exclure les valeurs manquantes de tous les calculs ci-dessus.\
-   Si vous appliquez des fonctions d'aide `adorn_*()` à des tables qui n'ont pas été crées par `tabyl()`, vous pouvez spécifier une ou plusieurs colonnes particulières auxquelles les appliquer comme `adorn_percentage(,,,c(cas,décès))` (spécifiez-les au 4ème argument non nommé). La syntaxe n'est pas simple. Pensez à utiliser `summarise()` à la place.\
-   Vous pouvez obtenir plus de détails dans le [janitor page](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) and this [tabyl vignette](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).

## **dplyr** package

**dplyr** fait partie des packages **tidyverse** et est un outil de gestion de données très courant. Créer des tableaux avec les fonctions **dplyr** `summarise()` et `count()` est une méthode très utile pour calculer des statistiques sommaires, résumer *par groupe*, ou passer des tableaux à `ggplot()`.

`summarise()` crée un *nouveau tableau de données récapitulatif*. Si les données sont *non groupées*, il renvoie un tableau de données à une ligne avec les statistiques récapitulatives spécifiées pour l'ensemble du tableau de données. Si les données sont *groupées*, le nouveau tableau de données aura une ligne par *groupe* (voir la page \[Regroupement de données\]).

Entre les parenthèses de `summarise()`, vous indiquez le nom de chaque nouvelle colonne du résumé, suivi d'un signe égal et d'une fonction statistique à appliquer.

[***TIP:*** La fonction summarise fonctionne avec les orthographes britannique et américaine (`summarise()` et `summarize()`).]{style="color: darkgreen;"}

### Obtenir des nombres {.unnumbered}

La fonction la plus simple à appliquer dans `summarise()` est `n()`. Laissez les parenthèses vides pour compter le nombre de lignes.

```{r}
linelist %>%                 # begin with linelist
  summarise(n_rows = n())    # return new summary dataframe with column n_rows
```

Cela devient plus intéressant si nous avons regroupé les données au préalable.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # group data by unique values in column age_cat
  summarise(n_rows = n())   # return number of rows *per group*
```

La commande ci-dessus peut être réduite en utilisant la fonction `count()` à la place. La fonction `count()` effectue les opérations suivantes :

1)  Regroupe les données selon les colonnes qui lui sont fournies.
2)  Les résume avec `n()` (en créant la colonne `n`).
3)  Dé-grouper les données

```{r}
linelist %>% 
  count(age_cat)
```

Vous pouvez changer le nom de la colonne des comptages de la valeur par défaut `n` à quelque chose d'autre en le spécifiant à `name =`.

Les résultats de la mise en tableau de deux colonnes de regroupement ou plus sont toujours renvoyés au format "long", avec les effectifs dans la colonne `n`. Consultez la page \[Pivoter les données\] pour en savoir plus sur les formats de données "long" et "large".

```{r}
linelist %>% 
  count(age_cat, outcome)
```

### Voir tous les niveaux {.unnumbered}

Si vous mettez en tableau une colonne de classe *facteur*, vous pouvez vous assurer que *tous* les niveaux sont affichés (et pas seulement les niveaux avec des valeurs dans les données) en ajoutant `.drop = FALSE` dans la commande `summarise()` ou `count()`.

Cette technique est utile pour standardiser vos tableaux/graphiques. Par exemple, si vous créez des chiffres pour plusieurs sous-groupes, ou si vous créez plusieurs fois le même chiffre pour des rapports de routine. Dans chacune de ces circonstances, la présence de valeurs dans les données peut fluctuer, mais vous pouvez définir des niveaux qui restent constants.

Consultez la page sur les \[Facteurs\] pour plus d'informations.

### Proportions {#tbl_dplyr_prop .unnumbered}

Les proportions peuvent être ajoutées en passant le tableau à `mutate()` pour créer une nouvelle colonne. Définissez la nouvelle colonne comme la colonne des comptages (`n` par défaut) divisée par la `sum()` de la colonne des comptages (ceci retournera une proportion).

Notez que dans ce cas, `sum()` dans la commande `mutate()` retournera la somme de la colonne entière `n` pour l'utiliser comme dénominateur de la proportion. Comme expliqué [dans la page Regroupement des données](#group_summarise), *si* `sum()` est utilisé dans des données *groupées* (par exemple, si la commande `mutate()` suit immédiatement une commande `group_by()`), il retournera les sommes *par groupe*. Comme indiqué juste au-dessus, `count()` termine ses actions en *dégroupant*. Ainsi, dans ce scénario, nous obtenons les proportions de la colonne entière.

Pour afficher facilement les pourcentages, vous pouvez inclure la proportion dans la fonction `percent()` du package **scales** (notez cette conversion en caractère de classe).

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # group and count by gender (produces "n" column)
  mutate(                                # create percent of column - note the denominator
    percent = scales::percent(n / sum(n))) 

# print
age_summary
```

Vous trouverez ci-dessous une méthode permettant de calculer les proportions *dans les groupes*. Elle repose sur l'application et la suppression sélectives de différents niveaux de regroupement des données. Tout d'abord, les données sont regroupées en fonction du `résultat` via `group_by()`. Ensuite, la fonction `count()` est appliquée. Cette fonction regroupe à nouveau les données par `age_cat` et retourne les résultats pour chaque combinaison `outcome`-`age-cat`. Il est important de noter qu'en terminant son processus, `count()` a également *dégroupé* le regroupement par `age_cat`, de sorte que le seul regroupement de données restant est le regroupement original par `outcome`. Ainsi, l'étape finale du calcul des proportions (dénominateur `sum(n)`) est toujours groupée par `outcome`.

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

### Plotting {.unnumbered}

Afficher un tableau "long" comme celui ci-dessus avec `ggplot()` est relativement simple. Les données sont naturellement au format "long", qui est naturellement accepté par `ggplot()`. Voir d'autres exemples dans les pages \[ggplot basics\] et \[ggplot tips\].

```{r, warning=F, message=F}
linelist %>%                      # begin with linelist
  count(age_cat, outcome) %>%     # group and tabulate counts by two columns
  ggplot()+                       # pass new data frame to ggplot
    geom_col(                     # create bar plot
      mapping = aes(   
        x = outcome,              # map outcome to x-axis
        fill = age_cat,           # map age_cat to the fill
        y = n))                   # map the counts column `n` to the height
```

### Synthèse des statistiques {.unnumbered}

Un avantage majeur de **dplyr** et de `summarise()` est la possibilité de retourner des résumés statistiques plus avancés comme `median()`, `mean()`, `max()`, `min()`, `sd()` (écart-type), et les percentiles. Vous pouvez également utiliser `sum()` pour retourner le nombre de lignes qui répondent à certains critères logiques. Comme ci-dessus, ces sorties peuvent être produites pour l'ensemble du cadre de données, ou par groupe.

La syntaxe est la même - entre les parenthèses de `summarise()`, vous fournissez les noms de chaque nouvelle colonne de résumé, suivis d'un signe égal et d'une fonction statistique à appliquer. Dans la fonction statistique, donnez la ou les colonnes sur lesquelles vous voulez travailler et tous les arguments pertinents (par exemple `na.rm = TRUE` pour la plupart des fonctions mathématiques).

Vous pouvez également utiliser `sum()` pour retourner le nombre de lignes qui répondent à un critère logique. L'expression qu'il contient est comptée si elle vaut `TRUE`. Par exemple :

-   `sum(age_years < 18, na.rm=T)`\
-   `sum(gender == "male", na.rm=T)`\
-   `sum(response %in% c("Likely", "Very Likely"))`

Ci-dessous, les données `linelist` sont résumées pour décrire le délai en jours entre l'apparition des symptômes et l'admission à l'hôpital (colonne `days_onset_hosp`), par hôpital.

```{r}
summary_table <- linelist %>%                                        # begin with linelist, save out as new object
  group_by(hospital) %>%                                             # group all calculations by hospital
  summarise(                                                         # only the below summary columns will be returned
    cases       = n(),                                                # number of rows per group
    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days
    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent 
  )

summary_table  # print
```

Quelques conseils :

-   Utilisez `sum()` avec une instruction logique pour "compter" les lignes qui répondent à certains critères (`==`).

-   Notez l'utilisation de `na.rm = TRUE` dans les fonctions mathématiques comme `sum()`, sinon `NA` sera retourné s'il y a des valeurs manquantes \`\`.

-   Utilisez la fonction `percent()` du package **scales** pour convertir facilement en pourcentages.

    -   Définissez `accuracy =` à 0,1 ou 0,01 pour garantir respectivement 1 ou 2 décimales.

-   Utilisez la fonction `round()` de **extension/package R base** pour spécifier les décimales.

-   Pour calculer ces statistiques sur l'ensemble des données, utilisez `summarise()` sans `group_by()`.

-   Vous pouvez créer des colonnes pour les besoins de calculs ultérieurs (par exemple, les dénominateurs) que vous supprimez éventuellement de votre cadre de données avec `select()`.

### Statistiques conditionnelles {.unnumbered}

Vous pouvez souhaiter renvoyer des *statistiques conditionnelles* - par exemple, le maximum de lignes qui répondent à certains critères. Pour ce faire, il suffit de subdiviser la colonne avec des parenthèses "\[ \]`". L'exemple ci-dessous renvoie la température maximale pour les patients classés comme ayant ou n'ayant pas de fièvre. Attention cependant - il peut être plus approprié d'ajouter une autre colonne à la commande`group_by()`et`pivot_wider()\` (comme démontré [ci-dessous](#tbls_pivot_wider)).

```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```

### Glueing together {.unnumbered}

La fonction `str_glue()` de **stringr** est utile pour combiner les valeurs de plusieurs colonnes en une nouvelle colonne. Dans ce contexte, elle est généralement utilisée *après* la commande `summarise()`.

Dans la page \[Caractères et chaînes de caractères\], diverses options pour combiner des colonnes sont discutées, notamment `unite()`, et `paste0()`. Dans ce cas d'utilisation, nous préconisons `str_glue()` parce qu'il est plus flexible que `unite()` et a une syntaxe plus simple que `paste0()`.

Ci-dessous, le tableau de données `summary_table` (créé plus haut) est modifié de telle sorte que les colonnes `delay_mean` et `delay_sd` sont combinées, la mise en forme entre parenthèses est ajoutée à la nouvelle colonne, et leurs anciennes colonnes respectives sont supprimées.

Ensuite, pour rendre le tableau plus présentable, une ligne de total est ajoutée avec `adorn_totals()` de **janitor** (qui ignore les colonnes non-numériques). Enfin, nous utilisons `select()` de **dplyr** pour réordonner et renommer les colonnes avec des noms plus appropriés.

Maintenant, vous pouvez passer à **flextable** et imprimer le tableau dans Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc. ! (voir la page \[Tableaux pour la présentation\]).

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combine and format other values
  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   
  adorn_totals(where = "row") %>%                            # add total row
  select(                                                    # order and rename cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Percentiles {.unnumbered}

*Les percentiles* et les quantiles dans **dplyr** méritent une mention spéciale. Pour retourner les quantiles, utilisez `quantile()` avec les valeurs par défaut ou spécifiez la ou les valeurs que vous souhaitez avec `probs =`.

```{r}
# get default percentile values of age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Si vous voulez retourner les quantiles *par groupe*, vous pouvez rencontrer des sorties longues et moins utiles si vous ajoutez simplement une autre colonne à `group_by()`. Donc, essayez plutôt cette approche - créez une colonne pour chaque niveau de quantile désiré.

```{r}
# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Bien que **dplyr** `summarise()` offre certainement un contrôle plus précis, vous trouverez peut-être que toutes les synthèses statistiques dont vous avez besoin peuvent être produites avec `get_summary_stat()` du package **rstatix**. Si l'on opère sur des données groupées, if retournera 0%, 25%, 50%, 75%, et 100%. Si elle est appliquée à des données non groupées, vous pouvez spécifier les percentiles avec `probs = c(.05, .5, .75, .98)`.

```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

### Synthèse des données agrégées {.unnumbered}

*Si vous commencez avec des données agrégées*, l'utilisation de `n()` renvoie le nombre de *lignes*, et non la somme des comptes agrégés. Pour obtenir la somme, utilisez `sum()` sur la colonne des comptages des données.

Par exemple, disons que vous commencez avec le tableau de données de comptage ci-dessous, appelé `linelist_agg` - il montre en format "long" le nombre de cas par résultat et par sexe.

Ci-dessous, nous créons cet exemple de tableau de données de comptage de `linelist` par résultat et par sexe (les valeurs manquantes sont supprimées pour plus de clarté).

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Pour additionner les valeurs (dans la colonne `n`) par groupe, vous pouvez utiliser `summarise()` mais définissez la nouvelle colonne égale à `sum(n, na.rm=T)`. Pour ajouter un élément de condition à l'opération de somme, vous pouvez utiliser la syntaxe des sous-ensembles \[ \] sur la colonne des comptages.

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

### `across()` multiples colonnes {.unnumbered}

Vous pouvez utiliser `summarise()` sur plusieurs colonnes en utilisant `across()`. Cela vous facilite la tâche lorsque vous voulez calculer les mêmes statistiques pour plusieurs colonnes. Placez `across()` dans `summarise()` et spécifiez ce qui suit :

-   `.cols =` comme un vecteur de noms de colonnes `c()` ou des fonctions d'aide "tidyselect" (expliquées ci-dessous)\`\
-   `.fns =` la fonction à exécuter (sans parenthèses) - vous pouvez en fournir plusieurs dans une `list()`.

Ci-dessous, la fonction `mean()` est appliquée à plusieurs colonnes numériques. Un vecteur de colonnes est nommé explicitement dans `.cols =` et une seule fonction `mean` est spécifiée (sans parenthèses) dans `.fns =`. Tout argument supplémentaire pour la fonction (par exemple `na.rm=TRUE`) est fourni après `.fns =`, séparé par une virgule.

Il peut être difficile de respecter l'ordre des parenthèses et des virgules lorsqu'on utilise `across()`. N'oubliez pas qu'à l'intérieur de `across()`, vous devez inclure les colonnes, les fonctions et tous les arguments supplémentaires nécessaires aux fonctions.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns
                   .fns = mean,                               # function
                   na.rm=T))                                  # extra arguments
```

Plusieurs fonctions peuvent être exécutées en même temps. Ci-dessous, les fonctions `mean` et `sd` sont fournies à `.fns =` dans une `list()`. Vous avez la possibilité de fournir des noms de caractères (par exemple "mean" et "sd") qui sont ajoutés dans les nouveaux noms de colonnes.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns
                   .fns = list("mean" = mean, "sd" = sd),    # multiple functions 
                   na.rm=T))                                 # extra arguments
```

Voici les fonctions d'aide "tidyselect" que vous pouvez fournir à `.cols =` pour sélectionner des colonnes :

-   `everything()` - toutes les autres colonnes non mentionnées\
-   `last_col()` - la dernière colonne\
-   `where()` - applique une fonction à toutes les colonnes et sélectionne celles qui sont VRAIES\
-   `starts_with()` - correspond à un préfixe spécifié. Exemple : `starts_with("date")`\
-   `ends_with()` - correspond à un suffixe spécifié. Exemple : \`ends_with("\_end")\`\`\
-   `contains()` - colonnes contenant une chaîne de caractères. Exemple : `contains("time")`\
-   `matches()` - pour appliquer une expression régulière (regex). Exemple : `contains("[pt]al")`\
-   `num_range()` -
-   `any_of()` - correspond si la colonne est nommée. Utile si le nom peut ne pas exister. Exemple : `any_of(date_onset, date_death, cardiac_arrest)`

Par exemple, pour retourner la moyenne de chaque colonne numérique, utilisez `where()` et fournissez la fonction `as.numeric()` (sans parenthèses). Tout cela reste dans la commande `across()`.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # all numeric columns in the data frame
    .fns = mean,
    na.rm=T))
```

### Pivot élargi {#tbls_pivot_wider .unnumbered}

Si vous préférez votre tableau en format "large", vous pouvez le transformer en utilisant la fonction **tidyr** `pivot_wider()`. Vous devrez probablement renommer les colonnes avec `rename()`. Pour plus d'informations, consultez la page sur \[le pivotement des données\].

L'exemple ci-dessous commence avec la table "longue" `age_by_outcome` de la \[section proportions\](#tbl_dplyr_prop). Nous le créons à nouveau et le présentons à l'impression, pour plus de clarté :

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Pour effectuer un pivot plus large, nous créons les nouvelles colonnes à partir des *valeurs* de la colonne existante `age_cat` (en définissant `names_from = age_cat`). Nous spécifions également que les nouvelles valeurs de la table proviendront de la colonne existante `n`, avec `values_from = n`. Les colonnes non mentionnées dans notre commande de pivotement (`outcome`) resteront inchangées à l'extrême gauche.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # keep only counts for simplicity
  pivot_wider(names_from = age_cat, values_from = n)  
```

### Total de lignes {#tbl_dplyr_totals .unnumbered}

Lorsque `summarise()` opère sur des données groupées, il ne produit pas automatiquement des statistiques "totales". Ci-dessous, deux approches pour ajouter une ligne de total sont présentées :

#### **janitor**'s `adorn_totals()` {.unnumbered}

Si votre table consiste uniquement en des nombres ou des proportions/pourcentages qui peuvent être additionnés en un total, alors vous pouvez ajouter des totaux *sum* en utilisant `adorn_totals()` de **janitor** comme décrit dans la section ci-dessus. Notez que cette fonction ne peut additionner que les colonnes numériques - si vous voulez calculer d'autres statistiques totales, voyez l'approche suivante avec **dplyr**.

Ci-dessous, `linelist` est groupé par sexe et résumé dans un tableau qui décrit le nombre de cas dont l'issue est connue, les décès et les guéris. En passant le tableau à `adorn_totals()`, on ajoute une ligne de total en bas reflétant la somme de chaque colonne. Les autres fonctions `adorn_*()` ajustent l'affichage comme indiqué dans le code.

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing
    n_death  = sum(outcome == "Death", na.rm=T),    # Number of rows in group where outcome is Death
    n_recover = sum(outcome == "Recover", na.rm=T), # Number of rows in group where outcome is Recovered
  ) %>% 
  adorn_totals() %>%                                # Adorn total row (sums of each numeric column)
  adorn_percentages("col") %>%                      # Get column proportions
  adorn_pct_formatting() %>%                        # Convert proportions to percents
  adorn_ns(position = "front")                      # display % and counts (with counts in front)
```

#### `summarise()` Sur "total" des données et ensuite `bind_rows()` {.unnumbered}

Si votre tableau est composé de données de synthèse statistiques telles que `median()`, `mean()`, etc, l'approche `adorn_totals()` présentée ci-dessus ne sera *pas* suffisante. Pour obtenir des données de synthèse pour l'ensemble des données, vous devez les calculer avec une commande séparée `summarise()` et ensuite lier les résultats au tableau de synthèse original. Pour faire la liaison, vous pouvez utiliser `bind_rows()` de **dplyr** comme décrit dans la page \`\[Joining data\]. Vous trouverez ci-dessous un exemple :

Vous pouvez faire un tableau de synthèse des résultats *par hôpital* avec `group_by()` et `summarise()` comme ceci :

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T))               # median CT value per group
  
by_hospital # print table
```

Pour obtenir les totaux, exécutez la même commande `summarise()` mais regroupez les données uniquement par résultat (et non par hôpital), comme ceci :

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # These statistics are now by outcome only     
        ct_value = median(ct_blood, na.rm=T))

totals # print table
```

Nous pouvons lier ces deux tableaux ensemble. Notez que `by_hospital` a 4 colonnes alors que `totals` a 3 colonnes. En utilisant `bind_rows()`, les colonnes sont combinées par nom, et tout espace supplémentaire est rempli avec `NA` (par exemple les valeurs de la colonne `hospital` pour les deux nouvelles lignes `totals`). Après avoir lié les lignes, nous convertissons ces espaces vides en "Total" en utilisant `replace_na()` (voir la page \[Nettoyage des données et des fonctions de base\]).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Voici le nouveau tableau avec les lignes "Total" en bas.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Ce tableau est dans un format "long", ce qui peut correspondre à ce que vous souhaitez. *En option*, vous pouvez *pivoter* ce tableau *plus large* pour le rendre plus lisible. Consultez la section sur le pivotement plus large ci-dessus, ainsi que la page \[Pivoter les données\]. Vous pouvez également ajouter plus de colonnes, et les arranger joliment. Ce code se trouve ci-dessous.

```{r}
table_long %>% 
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)

```

Et vous pouvez ensuite afficher ce tableau sous la forme d'une image. Vous trouverez ci-dessous le résultat imprimé avec **flextable**. Vous pouvez lire plus en détail cet exemple et la façon d'obtenir ce "joli" tableau sur la page \[Tableaux pour la présentation\].

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make pretty images of tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

table <- linelist %>% 
  # filter
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  
  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)

  # formatting
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```

## **gtsummary** package {#tbl_gt}

Si vous voulez afficher vos synthèses statistiques dans un joli graphique, vous pouvez utiliser le package **gtsummary** et sa fonction `tbl_summary()`. Le code peut sembler complexe au début, mais les résultats sont très jolis et apparaissent dans votre panneau de visualisation RStudio sous forme d'image HTML. Lire une [vignette ici](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).

Vous pouvez également ajouter les résultats des tests statistiques aux tableaux **gtsummary**. Ce processus est décrit dans la section **gtsummary** de la page [Tests statistiques simples](#stats_gt).

Pour présenter `tbl_summary()`, nous allons d'abord montrer le comportement le plus basique, qui produit effectivement un grand et beau tableau. Ensuite, nous examinerons en détail comment faire des ajustements et des tableaux plus adaptés.

### Tableau de synthèse {.unnumbered}

Le comportement par défaut de `tbl_summary()` est assez incroyable - il prend les colonnes que vous fournissez et crée un tableau de synthèse en une seule commande. La fonction affiche les statistiques appropriées à la classe de la colonne : la médiane et l'écart inter-quartile (IQR) pour les colonnes numériques, et le nombre (%) pour les colonnes catégorielles. Les valeurs manquantes sont converties en "Inconnu". Des notes de bas de page sont ajoutées en bas de page pour expliquer les statistiques, tandis que le N total est affiché en haut de page.

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest
  tbl_summary()                                                  # default
```

### Ajustements {.unnumbered}

Nous allons maintenant expliquer le fonctionnement de la fonction et la manière de procéder aux ajustements. Les principaux arguments sont détaillés ci-dessous :

**`by =`**\
Vous pouvez stratifier votre tableau par une colonne (par exemple par `outcome`), créant ainsi un tableau à 2 dimensions.

**`statistic =`**\
Utilisez une équation pour spécifier les statistiques à afficher et comment les afficher. L'équation comporte deux côtés, séparés par un tilde `~`. Sur le côté droit, entre guillemets, se trouve l'affichage statistique souhaité, et sur la gauche se trouvent les colonnes auxquelles cet affichage s'appliquera.

-   Le côté droit de l'équation utilise la syntaxe de `str_glue()` de **stringr** (voir \[Characters and Strings\]), avec la chaîne d'affichage souhaitée entre guillemets et les statistiques elles-mêmes entre crochets. Vous pouvez inclure des statistiques comme "n" (pour les comptes), "N" (pour le dénominateur), "mean", "median", "sd", "max", "min", les percentiles comme "p##" comme "p25", ou le pourcentage du total comme "p". Voir `?tbl_summary` pour plus de détails.\
-   Pour le côté gauche de l'équation, vous pouvez spécifier les colonnes par leur nom (par exemple, `age` ou `c(age, gender)`) ou en utilisant des aides telles que `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, etc.

Un exemple simple d'équation `statistic =` pourrait ressembler à ce qui suit, pour afficher uniquement la moyenne de la colonne `age_years` :

```{r}
linelist %>% 
  select(age_years) %>%         # keep only columns of interest 
  tbl_summary(                  # create summary table
    statistic = age_years ~ "{mean}") # print mean of age
```

Une équation un peu plus complexe pourrait ressembler à ""({min}, {max})"\`, incorporant les valeurs max et min entre parenthèses et séparées par une virgule :

```{r}
linelist %>% 
  select(age_years) %>%                       # keep only columns of interest 
  tbl_summary(                                # create summary table
    statistic = age_years ~ "({min}, {max})") # print min and max of age
```

Vous pouvez également différencier la syntaxe pour des colonnes ou des types de colonnes distincts. Dans l'exemple plus complexe ci-dessous, la valeur fournie à `statistc =` est une **liste** indiquant que pour toutes les colonnes continues, le tableau doit afficher la moyenne avec l'écart-type entre parenthèses, tandis que pour toutes les colonnes catégorielles, il doit afficher le n, le dénominateur et le pourcentage.

**`digits =`**\
Ajuste les chiffres et les arrondis. En option, il est possible de spécifier que cela ne concerne que les colonnes continues (comme ci-dessous).

**`label =`**\
Ajustez la façon dont le nom de la colonne doit être affiché. Fournissez le nom de la colonne et son étiquette souhaitée, séparés par un tilde. La valeur par défaut est le nom de la colonne.

**`missing_text =`**\
Ajustez la façon dont les valeurs manquantes sont affichées. La valeur par défaut est "Inconnu".

**`type =`**\
Permet de régler le nombre de niveaux de statistiques à afficher. La syntaxe est similaire à `statistic =` en ce sens que vous fournissez une équation avec des colonnes à gauche et une valeur à droite. Voici deux scénarios courants :

-   `type = all_categorical() ~ "categorical"` Force les colonnes dichotomiques (par exemple, `fièvre` oui/non) à montrer tous les niveaux au lieu de ne montrer que la ligne "oui"
-   `type = all_continuous() ~ "continuous2"` Permet des statistiques multi-lignes par variable, comme indiqué dans une section ultérieure.

Dans l'exemple ci-dessous, chacun de ces arguments est utilisé pour modifier le tableau de synthèse original :

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest
  tbl_summary(     
    by = outcome,                                               # stratify entire table by outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # stats and format for continuous columns
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # stats and format for categorical columns
    digits = all_continuous() ~ 1,                              # rounding for continuous columns
    type   = all_categorical() ~ "categorical",                 # force all categorical levels to display
    label  = list(                                              # display labels for column names
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # how missing values should display
  )
```

### Statistiques multi-lignes pour les variables continues {.unnumbered}

Si vous souhaitez afficher plusieurs lignes statistiques pour des variables continues, vous pouvez l'indiquer en définissant le `type =` à "continuous2". Vous pouvez combiner tous les éléments présentés précédemment dans un seul tableau en choisissant les statistiques que vous voulez afficher. Pour cela, vous devez indiquer à la fonction que vous voulez récupérer un tableau en entrant le type comme "continuous2". Le nombre de valeurs manquantes est indiqué comme "Inconnu".

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # keep only columns of interest
  tbl_summary(                                     # create summary table
    type = all_continuous() ~ "continuous2",       # indicate that you want to print multiple statistics 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # line 1: mean and SD
      "{median} ({p25}, {p75})",                   # line 2: median and IQR
      "{min}, {max}")                              # line 3: min and max
    )
```

Il existe de nombreuses autres façons de modifier ces tableaux, notamment en ajoutant des valeurs p, en ajustant la couleur et les titres, etc. La plupart sont décrites dans la documentation (entrez `?tbl_summary` dans Console), et certaines sont données dans la section sur les [tests statistiques](https://epirhandbook.com/simple-statistical-tests.html).

## **extension/package R base**

Vous pouvez utiliser la fonction `table()` pour faire des tableaux et des tableaux croisés de colonnes. Contrairement aux options ci-dessus, vous devez spécifier le tableau de données chaque fois que vous faites référence à un nom de colonne, comme indiqué ci-dessous.

[***CAUTION:*** `Les valeurs`NA`(manquantes) ne seront **pas** affichées en tableau, à moins que vous n'incluiez l'argument`useNA = "always"\` (qui peut également être défini sur "no" ou "ifany").]{style="color: orange;"}

[***TIP:*** Vous pouvez utiliser le `%$%` de **magrittr** pour supprimer la répétition des enregistrements de données du tableaux dans les fonctions **base**. Par exemple, on pourrait écrire `linelist %$% table(outcome, useNA = "always")`.]{style="color: darkgreen;"}

```{r}
table(linelist$outcome, useNA = "always")
```

Plusieurs colonnes peuvent être croisées en les listant l'une après l'autre, séparées par des virgules. En option, vous pouvez attribuer à chaque colonne un "nom" comme `Outcome = linelist$outcome`.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # save table as object
age_by_outcome   # print table
```

### Proportions {.unnumbered}

Pour retourner les proportions, passez le tableau ci-dessus à la fonction `prop.table()`. Utilisez l'argument `margins =` pour spécifier si vous voulez que les proportions soient des lignes (1), des colonnes (2), ou du tableau entier (3). Pour plus de précisions, nous envoyons le tableau à la fonction `round()` de **base** R, en spécifiant 2 chiffres.

```{r}
# get proportions of table defined above, by rows, rounded
prop.table(age_by_outcome, 1) %>% round(2)
```

### Totals {.unnumbered}

Pour ajouter les totaux des lignes et des colonnes, passez le tableau à `addmargins()`. Cela fonctionne à la fois pour les nombres et les proportions.

```{r}
addmargins(age_by_outcome)
```

### Convertir en tableau de données {.unnumbered}

Convertir un objet `table()` directement en tableau de données n'est pas simple. Une approche est démontrée ci-dessous :

1)  Créez la table, \*sans utiliser `useNA = "always"`. A la place, convertissez les valeurs `NA` en "(Missing)" avec `fct_explicit_na()` de **forcats**.\
2)  Ajoutez les totaux (facultatif) en utilisant \`addmargins()\`\`.
3)  Passez le tableau dans la fonction R **base** \`as.data.frame.matrix()\`\`.
4)  Passez le tableau dans la fonction **tibble** `rownames_to_column()`, en spécifiant le nom de la première colonne.
5)  Affichez, visualisez ou exportez comme vous le souhaitez. Dans cet exemple, nous utilisons `flextable()` du package **flextable** comme décrit dans la page \`\[Tableaux pour la présentation\]. Cela permettra d'afficher dans le volet de visualisation de RStudio une jolie image HTML.

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```

<!-- ======================================================= -->

## Ressources

La plupart des informations contenues dans cette page sont issues de ces ressources et des sites Internet :

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
