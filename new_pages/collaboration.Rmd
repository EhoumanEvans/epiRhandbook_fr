
# Contrôle de version et collaboration avec Git et Github [#collaboration]

Ce chapitre présente un aperçu de l'utilisation de Git pour collaborer avec d'autres personnes.
Des tutoriels plus complets peuvent être
en bas de page dans la section Ressources.

## Qu'est-ce que Git ?

Git est un logiciel de **contrôle de version** qui permet de suivre les modifications dans un
dossier. Il peut être utilisé comme l'option "track change" dans Word, LibreOffice ou Google docs, mais pour tous les types de fichiers.
Google docs, mais pour tous les types de fichiers. C'est l'une des options les plus puissantes
et les plus utilisées pour le contrôle de version.

**Pourquoi n'en ai-je jamais entendu parler ? **Les personnes ayant une formation de développeur
développeurs apprennent couramment à utiliser un logiciel de contrôle de version (Git,
Mercurial, Subversion ou autres), peu d'entre nous issus de disciplines
disciplines quantitatives sont enseignés ces compétences. Par conséquent, la plupart des épidémiologistes n'en
Par conséquent, la plupart des épidémiologistes n'en ont jamais entendu parler au cours de leurs études, et doivent l'apprendre à la volée.

**Attendez, j'ai entendu parler de Github, c'est la même chose ?
pas exactement, mais vous les utilisez souvent ensemble, et nous vous montrerons comment faire. En bref :

- **Git** est le système de contrôle de version, un logiciel. Vous pouvez l'utiliser
    localement sur votre ordinateur ou pour synchroniser un dossier avec un
    hôte **site web**. Par défaut, on utilise un terminal pour donner à Git
    en ligne de commande.

- Vous pouvez utiliser un **client/interface Git** pour éviter la ligne de commande et
    et effectuer les mêmes actions (au moins pour les actions simples et super courantes).
    courantes).

- Si vous souhaitez stocker votre dossier dans un **site web hôte** pour
    collaborer avec d'autres, vous pouvez créer un compte sur Github,
    Gitlab, Bitbucket ou autres.

Ainsi, vous pouvez utiliser le client/interface **Github Desktop**, qui utilise
**Git** en arrière-plan pour gérer vos fichiers, à la fois localement sur votre
ordinateur, et à distance sur un serveur **Github**.

## Pourquoi utiliser le combo Git et Github ?

L'utilisation de **Git** facilite :

1) L'archivage des versions documentées avec des modifications incrémentielles de sorte que vous
    afin que vous puissiez facilement revenir en arrière à n'importe quel état antérieur.
2) Avoir des *branches* parallèles, c'est-à-dire des versions de développement/"de travail" avec
    des moyens structurés pour intégrer les changements après révision

Cela peut être fait localement sur votre ordinateur, même si vous ne collaborez pas avec d'autres personnes.
avec d'autres personnes. Avez-vous déjà :

- regretté d'avoir supprimé une section de code, pour réaliser deux mois plus tard que vous en aviez en fait besoin ?
    mois plus tard que vous en aviez besoin ?


- revenir sur un projet qui avait été mis en pause et tenter de vous rappeler si vous aviez effectué cette opération délicate ?
    de vous souvenir si vous aviez effectué cette modification délicate dans l'un des modèles ?
    modèles ?

- aviez un *fichier modèle_1.R* et un autre fichier *modèle_1\_test.R* et un fichier
    *modèle_1\_non_fonctionnel.R* pour faire des essais ?

- avait un fichier *report.Rmd*, un fichier *report_full.Rmd*, un fichier
    *report_true_final.Rmd*, un fichier *report_final_20210304.Rmd*, un fichier
    *report_final_20210402.Rmd* et maudit vos compétences en archivage ?

Git vous aidera dans tout cela, et vaut la peine d'être appris pour cette seule raison.


Cependant, il devient encore plus puissant lorsqu'il est utilisé avec un référentiel en ligne
tel que Github pour soutenir des **projets collaboratifs**. Cela facilite :

- la collaboration : d'autres personnes peuvent examiner, commenter, et
    accepter/refuser des modifications

- Le partage de votre code, de vos données et de vos résultats, et l'invitation à faire des commentaires
    du public (ou en privé, avec votre équipe)

et éviter :

- "Oups, j'ai oublié d'envoyer la dernière version et maintenant vous devez
    refaire deux jours de travail sur ce nouveau fichier".

- Mina, Henry et Oumar ont tous travaillé en même temps sur un script et doivent
    doivent fusionner manuellement leurs modifications

- Deux personnes tentent de modifier le même fichier sur Dropbox et Sharepoint 
    et cela crée une erreur de synchronisation.

### Cela semble compliqué, je ne suis pas un programmeur {-}

Cela peut l'être. Les exemples d'utilisations avancées peuvent être assez effrayants. Cependant, un peu comme
Cependant, comme R, ou même Excel, vous n'avez pas besoin de devenir un expert pour profiter des
avantages de l'outil. L'apprentissage d'un *petit nombre de fonctions et de notions*...
vous permet de suivre vos modifications, de synchroniser vos fichiers sur un référentiel en ligne et de collaborer avec vos collègues.
en ligne et de collaborer avec vos collègues en très peu de temps.
de temps.

En raison de la courbe d'apprentissage, le contexte d'urgence n'est peut-être pas le meilleur moment
pour apprendre ces outils. Mais l'apprentissage peut se faire par étapes. Une fois que vous aurez acquis 
quelques notions, votre flux de travail peut être assez efficace et rapide.
Si vous ne travaillez pas sur un projet où la collaboration avec des personnes
par le biais de Git est une nécessité, **c'est en fait un bon moment pour devenir
l'utiliser** en solo avant de vous lancer dans la collaboration.

## Installation

### Installer Git {.unnumbered}

*Git* est le moteur qui se cache derrière les coulisses de votre ordinateur, qui suit
les changements, les branches (versions), les fusions et les retours en arrière. **Vous devez d'abord
installer *Git* à partir de <https://git-scm.com/downloads>.**

### Installer une interface (facultatif mais recommandé) {.unnumbered}

Git possède son propre langage de commandes, qui peuvent être tapées dans un terminal de ligne de commande.
dans un terminal de ligne de commande. Cependant, il existe de nombreux clients/interfaces et en tant que non-développeur, dans votre
dans votre utilisation quotidienne, vous aurez rarement _besoin_ d'interagir directement avec Git. 
L'interface Git fournit généralement des outils de visualisation agréables pour les modifications de fichiers ou les branches. 

De nombreuses options existent, sur tous les systèmes d'exploitation, des plus simples aux plus complexes. 
Parmi les bonnes options pour les débutants, citons le volet Git de RStudio et le [Github Desktop]. 
[Github Desktop] (https://desktop.github.com/), que nous présenterons dans ce chapitre. 
ce chapitre.
Les options intermédiaires (plus puissantes, mais plus complexes) comprennent Source Tree, 
Gitkracken, Smart Git et d'autres.

Explication rapide sur les [clients Git](-%09https:/happygitwithr.com/git-client.html#git-client).

*Remarque : comme les interfaces utilisent toutes Git en interne, vous pouvez en essayer plusieurs, passer de l'une à l'autre en fonction de vos besoins.
d'entre elles, passer de l'une à l'autre sur un projet donné, utiliser ponctuellement la console 
pour une action que votre interface ne prend pas en charge, ou même effectuer un certain nombre d'actions en ligne sur Github. 
actions en ligne sur Github.*

Comme indiqué ci-dessous, vous pouvez occasionnellement avoir à écrire des commandes Git dans un terminal
terminal tel que le volet terminal de RStudio (un onglet adjacent à la Console R
Console) ou le terminal Git Bash.


### Compte Github {.non numéroté}

Créez un compte gratuit sur [github.com](github.com).

Il se peut que l'on vous propose de configurer une authentification à deux facteurs avec une application sur votre téléphone.
votre téléphone. Pour en savoir plus, consultez le document Github [help
documents](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa).

Si vous utilisez Github Desktop, vous pouvez entrer vos informations d'identification Gitub après l'installation en suivant les étapes suivantes
l'installation en suivant ces
[étapes] (https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github).
Si vous ne le faites pas, les informations d'identification vous seront demandées ultérieurement lorsque vous tenterez de cloner un projet à partir de Github.
cloner un projet depuis Github.

## Vocabulaire, concepts et fonctions de base

Comme lors de l'apprentissage de R, il y a un peu de vocabulaire à retenir pour
comprendre Git. Voici les [bases pour vous aider à
démarrer](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/)
/ [tutoriel interactif](learngitbranching.js.org). Dans les prochaines
Dans les prochaines sections, nous montrerons comment utiliser les interfaces.
d'avoir le vocabulaire et les concepts en tête, pour construire votre modèle mental,
et comme vous en aurez besoin en utilisant les interfaces de toute façon.

### Référentiel {.non numéroté}

Un *référentiel* Git ("*repo*") est un dossier qui contient tous les sous-dossiers et fichiers de votre projet.
les sous-dossiers et les fichiers de votre projet (données, code, images, etc.) et
) et l'historique de leurs révisions. Lorsque vous commencez à suivre les changements dans le
dépôt, Git créera un dossier caché qui contient toutes les informations de
toutes les informations de suivi. Un référentiel Git typique est
votre dossier *R Project* (voir la page du manuel sur les [R projects]).

Nous allons montrer comment créer (_initialiser_) un dépôt Git 
Gitub, Github Desktop ou Rstudio dans les sections suivantes.
sections suivantes.

### Commits {.non numérotés}

Un *commit* est un **snapshot** du projet à un moment donné. 
Lorsque vous apportez un changement au projet, vous faites un nouveau commit
pour suivre les modifications (le delta) apportées à vos fichiers.
fichiers. Par exemple, vous avez peut-être édité quelques lignes de code et mis à jour une
jeu de données associé. Une fois que vos modifications sont enregistrées, vous pouvez regrouper ces
changements en un seul "commit".

Chaque commit a un ID unique (un *hash*). À des fins de contrôle de version,
vous pouvez revenir en arrière dans votre projet en vous basant sur les commits.
de les garder relativement petits et cohérents. Vous joindrez également une brève
brève description des modifications appelée "message de validation".

*Modifications organisées* ? Mettre en scène les changements, c'est les ajouter à la *zone de mise en scène*.
en préparation pour le prochain commit. L'idée est que vous pouvez finement
décider quels changements inclure dans un commit donné. Par exemple, si vous
par exemple, si vous avez travaillé sur la spécification d'un modèle dans un
un autre script, il serait judicieux d'avoir deux commits différents (ce serait plus facile
au cas où vous voudriez annuler les changements sur la figure mais pas sur le modèle).


### Branches {.non numérotées}

Une branche représente une ligne *indépendante* de changements dans votre repo, une version parallèle et alternative de votre projet.
version parallèle et alternative des fichiers de votre projet. 


Les branches sont utiles pour tester les modifications avant qu'elles ne soient incorporées dans
la branche *principale*, qui est généralement la version principale/finale/"live" de
votre projet. Lorsque vous avez fini d'expérimenter sur une branche, vous pouvez apporter
les changements dans votre branche *main*, en la *fusionnant*, ou la supprimer, si les
les changements n'ont pas été couronnés de succès.

*Note : vous n'avez pas besoin de collaborer avec d'autres personnes pour utiliser les branches,
ni d'avoir un référentiel en ligne distant.*



### Dépôts locaux et distants {.non numéroté}

*cloner* consiste à créer une copie d'un dépôt Git à un autre endroit.

Par exemple, vous pouvez *cloner* un dépôt en ligne _de_ Github localement sur
votre ordinateur, ou commencer par un dépôt local et le cloner en ligne
en ligne _vers_ Github.

Lorsque vous avez cloné un référentiel, les fichiers du projet existent à
deux endroits :

- le référentiel *LOCAL* sur votre ordinateur physique. Ce
    C'est là que vous apportez les modifications réelles aux fichiers/codes.

- le référentiel *ROMPU*, en ligne : les versions de vos fichiers de projet
    dans le dépôt Github (ou sur tout autre hébergeur).
    hôte web).

Pour synchroniser ces dépôts, nous allons utiliser d'autres fonctions. En effet ,
contrairement à Sharepoint, Dropbox ou autre logiciel de synchronisation, Git ne met pas
ne met pas automatiquement à jour votre dépôt local en fonction de ce qui est en ligne,
ou vice-versa. C'est vous qui choisissez quand et comment synchroniser.

- `git fetch` télécharge les nouvelles modifications depuis le dépôt distant mais ne modifie pas 
mais ne modifie pas votre dépôt local. Pensez-y comme une vérification de l'état du dépôt distant.

- `git pull` télécharge les nouvelles modifications depuis les dépôts distants
    et met à jour votre dépôt local.

- Lorsque vous avez fait un ou plusieurs commits localement, vous pouvez
    `git push` les commits vers le dépôt distant. Ceci envoie vos
    modifications sur Github afin que d'autres personnes puissent les voir et les tirer si
    s'ils le souhaitent.


## Démarrer : créer un nouveau dépôt

Il y a plusieurs façons de créer de nouveaux dépôts. Vous pouvez le faire à partir de la
console, depuis Github, depuis une interface.

Deux approches générales sont possibles :


- Créer un nouveau projet R à partir d'un dépôt Github existant ou nouveau.
    (*préféré pour les débutants*), ou bien
- Créer un dépôt Github pour un projet R existant.


### Fichiers de démarrage {.unnumbered}

Lorsque vous créez un nouveau référentiel, vous pouvez éventuellement créer 
tous les fichiers ci-dessous, ou vous pouvez les ajouter à votre référentiel à un stade ultérieur.
Ils se trouvent généralement dans le dossier "racine" du référentiel.

- Un fichier *README* est un fichier que quelqu'un peut lire pour comprendre pourquoi
    votre projet existe et ce qu'il doit savoir pour l'utiliser. Il
    sera vide au début, mais vous devriez le compléter plus tard.

- Un fichier *.gitignore* est un fichier texte dont chaque ligne contient
    des dossiers ou fichiers que Git devrait ignorer (ne pas suivre les modifications). Lisez
    plus sur ce sujet et voir des exemples
    [ici](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/).

- Vous pouvez choisir une *licence* pour votre travail, afin que les autres personnes
    les autres personnes sachent sous quelles conditions elles peuvent utiliser ou reproduire votre travail. Pour de plus amples
    informations, consultez la page [Creative Commons
    licenses] (https://creativecommons.org/licenses/).

### Créer un nouveau référentiel dans Github {.unnumbered}

Pour créer un nouveau dépôt, connectez-vous à Github et cherchez le bouton vert
pour créer un nouveau dépôt. Ce dépôt maintenant vide peut être
cloné localement sur votre ordinateur (voir la section suivante).

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

Vous devez choisir si vous voulez que votre dépôt soit **public** (visible par tout le monde sur Internet) ou **privé**.
tout le monde sur Internet) ou **privé** (seulement visible pour ceux qui ont la
permission). Cela a des implications importantes si vos données sont sensibles.
Si votre référentiel est privé, vous rencontrerez certains quotas dans des
circonstances particulières, par exemple si vous utilisez les *actions* de Github pour
exécuter automatiquement votre code dans le nuage.
 
### Clone à partir d'un dépôt Github {.unnumbered}

Vous pouvez *cloner* un référentiel Github existant pour créer
un nouveau projet R local sur votre ordinateur.

Le dépôt Github peut être un dépôt qui existe déjà et contient du contenu
contenu, ou un dépôt vide que vous venez de créer. Dans ce
Dans ce dernier cas, vous créez essentiellement le repo Github et le projet local R
local en même temps (voir les instructions ci-dessus).

Remarque : si vous n'avez pas de droits de contribution sur un dépôt Github, 
il est possible de d'abord _forker_ le dépôt vers votre profil, et ensuite
puis de procéder aux autres actions. La bifurcation est expliquée à la fin de ce chapitre. 
chapitre, mais nous vous recommandons de lire les autres sections d'abord.

Etape 1 : Naviguez dans Github jusqu'au dépôt, cliquez sur le bouton vert "**Code**".
et copier l'URL **HTTPS clone** (voir image ci-dessous)

``{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

L'étape suivante peut être effectuée dans n'importe quelle interface. Nous allons illustrer avec
Rstudio et le bureau Github.

#### Dans Rstudio {.unnumbered}

Dans RStudio, démarrez un nouveau projet R en cliquant sur *Fichier \> Nouveau projet \>.
Contrôle de version \> Git

- Lorsque vous êtes invité à saisir l'"URL du dépôt", collez l'URL HTTPS de
    Github\
- Attribuez au projet R un nom court et informatif.
- Choisissez l'endroit où le nouveau projet R sera enregistré localement.
- Cochez "Ouvrir dans une nouvelle session" et cliquez sur "Créer un projet".


Vous êtes maintenant dans un nouveau projet RStudio local qui est un clone du dépôt Github.
dépôt Github. Ce projet local et le dépôt Github sont maintenant
liés.

#### Dans le bureau de Github {.unnumbered}

- Cliquez sur *Fichier \> Cloner un référentiel*.

- Sélectionnez l'onglet URL

- Collez l'URL HTTPS de Github dans la première case.

- Sélectionnez le dossier dans lequel vous voulez avoir votre dépôt local.

- Cliquez sur "CLONE".

``{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### Nouveau repo Github à partir d'un projet R existant {.unnumbered}

Un autre scénario de configuration est que vous avez un projet R existant
avec du contenu, et que vous voulez créer un dépôt Github pour celui-ci.

1) Créez un nouveau dépôt Github vide pour le projet (cf.
    instructions ci-dessus).
2) Clonez ce dépôt localement (voir les instructions HTTPS ci-dessus).
3) Copiez tout le contenu de votre projet R
    (codes, données, etc.) dans ce nouveau dépôt local vide (utilisez le copier-coller, par exemple).
4) Ouvrez votre nouveau projet dans RStudio, et allez dans le volet Git. Les nouveaux fichiers devraient
    s'enregistrer comme des modifications de fichiers, désormais suivies par Git. Par conséquent, vous pouvez
    regrouper ces modifications sous forme de *commit* et les *pousser* vers Github.
    Une fois *poussé*, le dépôt sur Github reflétera tous les fichiers.
    
Voir la section sur le flux de travail Github ci-dessous pour plus de détails sur ce processus.

### A quoi cela ressemble-t-il maintenant ? {.unnumbered}

#### Dans RStudio {-}

Une fois que vous avez cloné un dépôt Github vers un nouveau projet R, 
vous voyez maintenant dans RStudio un onglet "Git". Cet onglet apparaît dans le même volet de RStudio que votre environnement R : {-}.
que votre environnement R :

``{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

Veuillez noter les boutons encerclés dans l'image ci-dessus, puisqu'ils seront
seront référencés plus tard (de gauche à droite) :

- Bouton pour *commettre* les modifications du fichier sauvegardé dans la branche
    locale (cela ouvrira une nouvelle fenêtre)
- Flèche bleue pour *pull* (mettre à jour votre version locale de la branche avec
    avec les changements effectués sur la version distante/Github de cette branche)
- Flèche verte pour *push* (envoyer tous les commits/modifications de votre version
    version locale de la branche vers la version distante/Github de cette branche)
- L'onglet Git dans RStudio
- Bouton pour créer une NOUVELLE branche en utilisant comme base la branche locale affichée
    à droite comme base. *Vous voulez presque toujours créer une branche à partir de la branche principale (après la première extraction).
    la branche principale (après avoir tiré pour mettre à jour la branche principale)*.
- La branche dans laquelle vous travaillez actuellement
- Les modifications que vous avez apportées au code ou à d'autres fichiers apparaissent ci-dessous

#### dans Github Desktop {-}

Github Desktop est une application indépendante qui vous permet de gérer
tous vos dépôts. Lorsque vous l'ouvrez, l'interface vous permet de
de choisir le dépôt sur lequel vous souhaitez travailler, puis d'effectuer les actions Git
à partir de là.

``{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```


### Flux de travail Git + Github

### Aperçu du processus {.unnumbered}

Une fois que vous avez terminé la configuration (décrite ci-dessus), vous aurez un
Github qui est connecté (*cloné*) à un projet R local. La branche
branche *main* (créée par défaut) est la version dite "live" de
*tous* les fichiers. Lorsque vous voulez faire des modifications, il est bon de créer une
pratique de créer une *nouvelle branche* à partir de la branche *main* (comme "Make a
copie"). Il s'agit d'un flux de travail typique de Git, car la création d'une branche est facile et rapide.
facile et rapide.


Un flux de travail typique est le suivant :

1.  Assurez-vous que votre dépôt local est à jour, mettez-le à jour si ce n'est
    pas

2.  Allez sur la branche sur laquelle vous travailliez précédemment, ou créez une nouvelle
    branche pour essayer certaines choses


3.  Travaillez sur les fichiers localement sur votre ordinateur, faites un ou plusieurs
    commits à cette branche

4.  Mettre à jour la version distante de la branche avec vos modifications (push)

5.  Lorsque vous êtes satisfait de votre branche, vous pouvez fusionner la version en ligne de la branche de travail avec la branche "principale" en ligne afin de créer une nouvelle branche.
    version en ligne de la branche de travail dans la branche "principale" en ligne pour
    transférer les modifications

Les autres membres de l'équipe peuvent faire la même chose avec leurs propres branches,
ou peut-être contribuer des commits dans votre branche de travail aussi. 

Nous détaillons ci-dessous le processus ci-dessus, étape par étape.
Voici un schéma que nous avons développé - il se présente sous la forme d'un tableau à double sens, ce qui devrait aider les épidémiologistes.
tableau à double sens, ce qui devrait aider les épidémiologistes à comprendre.

``{r echo=F, out.height='150%', out.width='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

Voici [un autre diagramme] (https://build5nines.com/introduction-to-git-version-control-workflow/).

*Note : jusqu'à récemment, le terme de branche "master" était utilisé, mais il est désormais
mais on parle maintenant de branche "principale".

``{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

Image
[source](https://build5nines.com/introduction-to-git-version-control-workflow/)

## Créer une nouvelle branche

Lorsque vous sélectionnez une branche sur laquelle travailler, **Git réinitialise votre répertoire de travail
comme il était la dernière fois que vous étiez sur cette branche**.

### Dans le volet Git de Rstudio {.unnumbered}

Assurez-vous que vous êtes dans la branche "principale", puis cliquez sur l'icône violette pour
créer une nouvelle branche (voir image ci-dessus).

- Vous serez invité à nommer votre branche avec un nom descriptif en un mot (vous pouvez utiliser des caractères de soulignement).
    descriptif en un mot (vous pouvez utiliser des caractères de soulignement si nécessaire).
- Vous verrez que, localement, vous êtes toujours dans le même projet R, mais que vous ne travaillez plus sur la branche "R".
    vous ne travaillez plus sur la branche "principale".
- Une fois créée, la nouvelle branche apparaîtra également sur le site Github
    comme une branche.
    
Vous pouvez visualiser les branches dans le volet Git de Rstudio après avoir cliqué sur "Historique".

``{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```


### Dans le bureau de Github {.unnumbered}

Le processus est très similaire, il vous est demandé de donner un nom à votre branche.
un nom. Ensuite, il vous sera demandé de "Publier votre branche sur Github" pour
pour que la nouvelle branche apparaisse également dans le dépôt distant.


``{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### Dans la console {.unnumbered}

Ce qui se passe en réalité dans les coulisses est que vous créez une nouvelle
nouvelle branche avec `git branch`, puis vous allez dans la branche avec
`git checkout` (_i.e._ dites à Git que vos prochains commits se feront là). 
Depuis votre dépôt git :

``{bash, eval = FALSE}
git branch my-new-branch # Créez la nouvelle branche
git checkout my-new-branch # Aller sur la branche
git checkout -b ma-nouvelle-branche # Les deux à la fois (raccourci)
```


Pour plus d'informations sur l'utilisation de la console, voir la section sur les
Commandes Git à la fin.

## Valider les changements

Vous pouvez maintenant modifier le code, ajouter de nouveaux fichiers, mettre à jour les ensembles de données, etc.


Chacune de vos modifications est suivie, *une fois que le fichier respectif est
sauvegardé*. Les fichiers modifiés apparaîtront dans l'onglet Git de RStudio, dans Github
Desktop, ou en utilisant la commande `git status` dans le terminal (voir ci-dessous).

Chaque fois que vous effectuez des modifications substantielles (par exemple, l'ajout ou la mise à jour d'une section de
code), faites une pause et *committez* ces changements. Pensez à un commit comme un "lot" de
de changements liés à un objectif commun. Vous pouvez toujours continuer à
réviser un fichier après y avoir apporté des modifications.

*Conseil sur les commits : en général, il est préférable de faire de petits commits, qui
qui peuvent être facilement annulées si un problème survient, pour commiter ensemble
des modifications liées à un objectif commun. Pour y parvenir, vous
vous trouverez que *vous devez commiter souvent*. Au début, vous allez probablement
oublier de commiter souvent, mais ensuite l'habitude s'installe.

### Dans Rstudio {.unnumbered}

L'exemple ci-dessous montre que, depuis le dernier commit, le script R Markdown "collaboration.Rmd" a été modifié, 
et plusieurs images PNG ont été ajoutées.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

Vous vous demandez peut-être ce que représentent les carrés jaunes, bleus, verts et rouges à côté
les noms de fichiers. Voici un instantané de la [feuille de route RStudio
cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
qui explique leur signification. Notez que les changements avec des " ?" jaunes peuvent toujours être
peuvent toujours être mises en scène, validées et poussées.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```

- Cliquez sur le bouton "Commit" dans l'onglet Git, ce qui ouvrira une nouvelle fenêtre (voir ci-dessous).
    fenêtre (montrée ci-dessous)

- Cliquez sur le nom d'un fichier dans le cadre supérieur gauche.

- Passez en revue les modifications que vous avez apportées à ce fichier (surlignées en vert ou en rouge ci-dessous).
    ou rouge)

- "Mettez en scène" le fichier, ce qui inclura ces modifications dans le commit. Faites
    en cochant la case à côté du nom du fichier. Alternativement, vous pouvez
    pouvez mettre en surbrillance plusieurs noms de fichiers, puis cliquer sur "Stage".

- Rédigez un message de validation court mais descriptif (obligatoire).

- Appuyez sur le bouton "Commit". Une boîte de dialogue apparaîtra, indiquant le succès
    ou un message d'erreur.


Vous pouvez maintenant effectuer d'autres modifications et d'autres livraisons, autant de fois que vous le souhaitez.

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### Dans le bureau de Github {.unnumbered}

Vous pouvez voir la liste des fichiers qui ont été modifiés sur la gauche. Si
vous sélectionnez un fichier texte, vous verrez un résumé des modifications qui ont été apportées
dans le volet de droite (cette vue ne fonctionnera pas sur des fichiers plus complexes comme les .docs ou les .xlsx).

Pour mettre en scène les modifications, il suffit de cocher la petite case près des noms de fichiers. Lorsque vous avez
avez sélectionné les fichiers que vous souhaitez ajouter à cette livraison, donnez un nom à la livraison, une description facultative et un mot de passe.
un nom, éventuellement une description, puis cliquez sur le bouton **commit**.
et cliquez sur le bouton **commit**.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### Dans la console {.unnumbered}

Les deux fonctions utilisées dans les coulisses sont `git add` pour sélectionner/établir
et `git commit` pour effectuer la livraison.

``{bash, eval = FALSE}
git status # voir les changements 

git add new_pages/collaboration.Rmd # sélectionner les fichiers à livrer (= mettre en scène les changements)

git commit -m "Describe commit from Github Desktop" # livrer les changements avec un message

git log # affiche les informations sur les commits passés
```


### Modifier un commit précédent {.unnumbered}

Que se passe-t-il si vous commettez des changements, continuez à travailler et réalisez que vous avez fait des changements qui devraient "appartenir" à l'auteur ?
que vous avez fait des changements qui devraient "appartenir" au commit précédent (à votre avis). 
N'ayez crainte ! Vous pouvez ajouter ces changements à votre validation précédente.

Dans Rstudio, cela devrait être assez évident puisqu'il y a une case "Amend previous commit" sur la même ligne que le COMMIT. 
sur la même ligne que le bouton COMMIT. 

Pour une raison peu claire, la fonctionnalité n'a pas été implémentée comme telle 
n'a pas été implémentée en tant que telle dans Github Desktop, mais il existe une
moyen de la contourner. Si vous avez validé **mais pas encore poussé** vos changements, 
un bouton "UNDO" apparaît juste en dessous du bouton COMMIT. Cliquez dessus et 
il annulera votre validation (mais conservera vos fichiers indexés et votre message de validation). 
Sauvegardez vos changements, ajoutez de nouveaux fichiers à la livraison si nécessaire et livrez à nouveau.

Dans la console :  

``{bash, eval = FALSE}
git add [YOUR FILES] # Ajoute vos nouvelles modifications

git commit --amend # Modifie le commit précédent

git commit --amend -m "An updated commit message" # Modifie la livraison précédente ET met à jour le message de livraison.
```


_Note : réfléchissez avant de modifier des commits qui sont déjà publics et partagés avec vos collaborateurs_.


## Tirez et poussez les modifications vers Github

"D'abord PULL, ensuite PUSH"

C'est une bonne pratique de *fetch* et de *pull* avant de commencer à travailler sur
votre projet, afin de mettre à jour la version de la branche sur votre ordinateur local avec
toutes les modifications qui ont été apportées dans la version distante/Github.

PULL souvent. N'hésitez pas. *Tirez toujours avant de pousser.

Lorsque vos modifications sont effectuées et validées et que vous êtes satisfait de l'état de votre projet, vous pouvez *tirer avant de pousser*. 
état de votre projet, vous pouvez *pousser* vos commits vers la version
vers la version distante/Github de votre branche.


Rincez et répétez pendant que vous travaillez sur le référentiel.

**Note:** il est beaucoup plus facile de revenir sur des modifications qui ont été commises mais pas poussées (c'est-à-dire qu'elles sont toujours en cours de traitement). 
mais qui n'ont pas été poussées (c.-à-d. qui sont encore locales) que de revenir sur des changements qui ont été poussés vers le
poussées vers le dépôt distant (et peut-être déjà extraites par quelqu'un d'autre). 
de pousser lorsque vous avez fini d'introduire des changements dans la tâche sur laquelle 
sur laquelle vous travailliez.


#### Dans Rstudio {.unnumbered}

*PULL* - Cliquez d'abord sur l'icône "Pull" (flèche vers le bas) qui récupère et tire en même temps.
tire en même temps.

*PUSH* - Cliquez sur l'icône verte "Pull" (flèche vers le haut). Il peut vous être demandé
d'entrer votre nom d'utilisateur et votre mot de passe Github. La première fois qu'ils vous
la première fois, vous devrez peut-être entrer deux lignes de commande Git dans le *Terminal* :

- **git config --global utilisateur.email
    "[you\@example.com](mailto:you@example.com){.email}"** (votre adresse électronique Github
    ), et **.
- **git config --global user.name "Votre nom d'utilisateur Github "**.

Pour en savoir plus sur la façon de saisir ces commandes, consultez la section ci-dessous
sur les commandes Git.

***TIP:*** On vous demande trop souvent de fournir votre mot de passe ? Consultez les chapitres
10 & 11 de ce
[tutoriel](https://happygitwithr.com/credential-caching.html#credential-caching)
pour se connecter à un référentiel en utilisant une clé SSH (plus
compliqué)  


#### Dans le bureau de Github {.unnumbered} (en anglais)

Cliquez sur le bouton "Fetch origin" pour vérifier s'il y a de nouveaux commits sur le dépôt distant.
sur le référentiel distant.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

Si Git trouve de nouveaux commits sur le dépôt distant, le bouton se
se transformera en bouton "Pull". Comme le même bouton est utilisé pour pousser et
pousser et tirer, vous ne pouvez pas pousser vos modifications si vous ne tirez pas auparavant.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

Vous pouvez aller dans l'onglet "History" (près de l'onglet "Changes") pour voir toutes les
commits (les vôtres et ceux des autres). C'est un bon moyen de savoir ce que vos collaborateurs ont fait.
ce que vos collaborateurs ont fait. Vous pouvez lire le message du commit, la
description s'il y en a une, et comparer le code des deux fichiers en utilisant le volet
le panneau *diff*.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

Une fois que toutes les modifications distantes ont été tirées, et qu'au moins une modification locale
a été validée, vous pouvez pousser en cliquant sur le même bouton.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Console {.unnumbered}

Sans surprise, les commandes sont *fetch*, *pull* et *push*.

``{bash, eval = FALSE}
git fetch # Y a-t-il de nouveaux commits dans le répertoire distant ?
git pull # Apporte les commits distants dans votre branche locale
git push # Pousse les commits locaux de cette branche vers la branche distante
```


### Je veux tirer mais j'ai du travail local {.unnumbered}

Cela peut arriver parfois : 
vous avez effectué des modifications sur votre dépôt local, mais le dépôt distant
mais le dépôt distant a des commits que vous n'avez pas tirés. 


Git refusera de les extraire car cela pourrait écraser vos modifications. 
Il existe plusieurs stratégies pour conserver vos modifications, 
bien décrites dans [Happy Git with R](https://happygitwithr.com/pull-tricky.html), 
parmi lesquelles les deux principales sont :
- livrer vos modifications, récupérer les modifications distantes, les tirer, résoudre les conflits 
si nécessaire (voir la section ci-dessous), et pousser le tout en ligne
- `stash` vos changements, ce qui les met en quelque sorte de côté, les tirer, les déstocker 
(restauration), puis commit, résolution des conflits, et push. 

Si les fichiers concernés par les modifications distantes et les fichiers concernés 
par vos modifications locales ne se chevauchent pas, Git peut résoudre les conflits automatiquement.

Dans Github Desktop, cela peut être fait avec des boutons. Pour mettre en cache, allez dans _Branch > Stash all changes_.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_stash.png"))
```



## Fusionner la branche dans Main 

Si vous avez fini de faire des changements, vous pouvez commencer le processus de
fusionner ces changements dans la branche principale. En fonction de votre situation,
cela peut être rapide, ou vous pouvez avoir des étapes délibérées de révision et d'approbation
impliquant des coéquipiers.

### Localement dans Github Desktop {.unnumbered}

On peut fusionner des branches localement en utilisant Github Desktop. Tout d'abord, allez dans
(checkout) la branche qui sera le destinataire des commits, en d'autres termes, la branche
branche que vous voulez mettre à jour. Ensuite, allez dans le menu *Branche \> Fusionner en
branche actuelle* et cliquez. Une boîte vous permet de sélectionner la branche à partir de laquelle vous souhaitez
la branche à partir de laquelle vous voulez importer.

``{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### Dans la console {.unnumbered}

Revenez d'abord à la branche qui sera le destinataire des changements.
C'est généralement *master*, mais cela peut être une autre branche. Ensuite, fusionnez votre
branche de travail dans master.

``{bash, eval = FALSE}
git checkout master # Retournez à master (ou à la branche que vous voulez déplacer)
git merge this_fancy_new_branch
```

[Cette
page](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)
montre un exemple plus avancé de branchement et explique un peu ce qui se passe en
ce qui se passe en coulisses.

### Dans Github : soumettre des demandes de pull {.unnumbered}


S'il est tout à fait possible de fusionner deux branches localement, ou sans en
sans en informer qui que ce soit, une fusion peut être discutée ou étudiée par plusieurs
personnes avant d'être intégrée à la branche master. Pour aider à ce
processus, Github propose des fonctionnalités de discussion autour de la fusion : la
**pull request**.

Une pull request (une "PR") est une demande de fusion d'une branche dans une autre 
(en d'autres termes, une demande pour que _votre branche de travail soit intégrée à la branche "principale"_). 
Une pull request implique généralement plusieurs commits. Une pull request commence généralement une conversation et un processus de révision 
avant qu'elle ne soit acceptée et que la branche ne soit fusionnée. Par exemple, 
vous pouvez lire les discussions sur les demandes de téléchargement sur le site [dplyr's
github] (https://github.com/tidyverse/dplyr/pulls).


Vous pouvez soumettre une demande de modification (PR) directement à partir du site Web (comme illustré ci-dessous) ou à partir de Github.
site Web (comme illustré ci-dessous) ou à partir du bureau Github.

- Accéder au dépôt Github (en ligne)
- Affichez l'onglet "Pull Requests" et cliquez sur le bouton "New pull request".
- Choisissez dans le menu déroulant de fusionner votre branche avec la branche principale.
- Rédigez un commentaire détaillé de la Pull Request et cliquez sur "Create Pull
    demande".

Dans l'image ci-dessous, la branche "forests" a été sélectionnée pour être fusionnée dans "main".
dans "main" :

``{r echo=F, out.width = '100%', out.height='150%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

Maintenant vous devriez être capable de voir la pull request (image d'exemple ci-dessous) :

- Passez en revue l'onglet "Fichiers modifiés" pour voir comment la branche "principale" serait
    changerait si la branche était fusionnée.
- Sur la droite, vous pouvez demander une révision aux membres de votre équipe en
    en marquant leur identifiant Github. Si vous le souhaitez, vous pouvez définir les paramètres du référentiel
    pour qu'une révision approuvée soit nécessaire afin de fusionner avec la branche
    main.\
- Une fois la demande de retrait approuvée, un bouton permettant de
    "Merge pull request" devient actif. Cliquez dessus.
- Une fois terminé, supprimez votre branche comme expliqué ci-dessous.

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### Résolution des conflits {.unnumbered}

Lorsque deux personnes modifient la ou les mêmes lignes au même moment, un
conflit de fusion se produit. En effet, Git refuse de prendre une décision quant à
version à conserver, mais il vous aide à trouver où se trouve le conflit.
conflit. **NE PANIQUEZ PAS**. La plupart du temps, il est assez simple à
à résoudre.

Par exemple, sur Github :

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```


Après que la fusion ait soulevé un conflit, ouvrez le fichier dans votre éditeur préféré.
Le conflit sera indiqué par une série de caractères :

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

Le texte entre *<<<<<<<<<<<<<<<<< HEAD* et *=======* provient de votre référentiel
dépôt local, et celui entre *=======* et *\>\>\>\>\>\>\>\>* de l'autre branche (qui peut être d'origine).
l'autre branche (qui peut être origin, master ou toute autre branche de
votre choix).

Vous devez décider quelle version du code vous préférez (ou même écrire une
troisième, en incluant les changements des deux côtés si cela est pertinent), effacer le reste
et retirer toutes les marques que Git a ajoutées *(\\N<<<<<<<<<<<< HEAD, =======,
\>\>\>\>\>\> origin/master/your_branch_name*). 

Ensuite, sauvegardez le fichier, mettez-le en scène et commitez-le : c'est le commit 
qui rend la version fusionnée "officielle". N'oubliez pas de pousser ensuite.

Plus vous et vos collaborateurs tirent et poussent souvent, plus les conflits seront réduits.
conflits seront réduits.


*Note : Si vous vous sentez à l'aise avec la console, il existe des outils plus [avancés] de
fusionner
options](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging)
(par exemple, ignorer les espaces, donner la priorité à un collaborateur, etc.)

### Supprimer votre branche {.unnumbered}

Une fois qu'une branche a été fusionnée dans master et n'est plus nécessaire, vous pouvez
la supprimer.

#### Github + Rstudio

Allez sur le dépôt sur Github et cliquez sur le bouton pour afficher toutes les branches (à côté de la liste déroulante pour les branches).
branches (à côté de la liste déroulante pour sélectionner les branches). Trouvez maintenant votre
branche et cliquez sur l'icône de la corbeille à côté d'elle. Lisez plus de détails sur la suppression
une branche
[ici] (https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting-branches-within-your-repository#deleting-a-branch).

Assurez-vous de supprimer également la branche localement sur votre ordinateur. Cela ne se fera pas
Cela ne se fera pas automatiquement.

- Depuis RStudio, assurez-vous que vous êtes dans la branche Main.
- Passez à la saisie de commandes Git dans le "Terminal" de RStudio (l'onglet
    adjacent à la console R), et tapez : **git branch -d
    nom_branche**, où "nom_branche" est le nom de la branche à supprimer.
    supprimée
- Rafraîchissez votre onglet Git et la branche devrait avoir disparu.


#### dans le bureau de Github

Vérifiez simplement la branche que vous voulez supprimer, et allez dans le menu
*Branche \> Supprimer*.


### Forking {.unnumbered} (bifurcation)

Vous pouvez forker un projet si vous souhaitez y contribuer mais que vous n'avez pas les droits pour le faire. 
mais n'avez pas les droits pour le faire, ou si vous voulez simplement 
simplement le modifier pour votre usage personnel. A 
courte description de la bifurcation se trouve [ici] (https://guides.github.com/activities/forking/).

Sur Github, cliquez sur le bouton "Fork" :  

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

Ceci clonera le dépôt original, mais dans votre propre profil. Donc maintenant, 
il y a deux versions du dépôt **sur Github** : l'original,
que vous ne pouvez pas modifier, et la version clonée dans votre profil.

Ensuite, vous pouvez procéder au clonage de votre version du dépôt en ligne en local 
sur votre ordinateur, en utilisant l'une des méthodes décrites dans les sections précédentes. 
Ensuite, vous pouvez créer une nouvelle branche, faire des changements, les livrer et les pousser 
vers votre dépôt distant.

Une fois que vous êtes satisfait du résultat, vous pouvez créer une Pull Request 
à partir de Github ou de Github Desktop pour entamer la conversation avec les 
propriétaires/mainteneurs du dépôt d'origine.


**Et si vous avez besoin de commits plus récents du dépôt officiel?**

Imaginez que quelqu'un apporte une modification critique au dépôt officiel,
que vous voulez inclure dans votre version clonée.
Il est possible de synchroniser votre fork avec le dépôt officiel. 
Cela implique l'utilisation du terminal, mais ce n'est pas trop compliqué. 
Vous devez surtout vous rappeler que :
- _upstream_ = le dépôt officiel, celui que vous n'avez pas pu modifier.
- _origin_ = votre version du dépôt sur votre profil Github


Vous pouvez lire [ce tutoriel] (https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) ou suivre les instructions ci-dessous : 


Tout d'abord, tapez dans votre terminal Git (à l'intérieur de votre repo) :  

``{bash, eval = FALSE}
git remote -v
```
 
Si vous n'avez pas encore configuré le référentiel amont, vous devriez 
vous devriez voir deux lignes, commençant par _origin_. Elles montrent le dépôt distant 
vers lequel `fetch` et `push` pointent. Rappelez-vous, _origin_ est le surnom conventionnel
surnom conventionnel pour votre propre version du dépôt sur Github. Par exemple :  

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

Maintenant, ajoutez un nouveau dépôt distant :  

``{bash, eval = FALSE}
git remote add upstream https://github.com/epirhandbook/Epi_R_handbook.git
```
 
Ici, l'adresse est l'adresse que Github génère lorsque vous clonez
un dépôt (voir la section sur le clonage). Vous aurez maintenant quatre pointeurs distants :

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

Maintenant que la configuration est faite, chaque fois que vous voulez obtenir les changements de 
le dépôt original (_upstream_), il suffit d'aller (_checkout_) dans la branche 
la branche que vous voulez mettre à jour et taper :

``{bash, eval = FALSE}
git fetch upstream # Obtenir les nouveaux commits du dépôt distant
git checkout la_branche_que_vous_voulez_mettre_à_jour
git merge upstream/the_branch_you_want_to_update # Fusionne la branche amont dans votre branche.
git push # Mettez à jour votre propre version du dépôt distant.
```

S'il y a des conflits, vous devrez les résoudre, comme expliqué 
dans la section Résoudre les conflits. 


**Résumé** : forker est un clonage, mais du côté du serveur Github. 
Le reste des actions sont des actions typiques du flux de travail de collaboration 
(cloner, pousser, tirer, commettre, fusionner, soumettre des demandes de tirage...).

Remarque : si la bifurcation est un concept et non une commande Git, elle existe aussi sur d'autres hôtes Web, comme [Bitbucket] (https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow).


``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```


## Ce que nous avons appris

Vous avez appris à :  

- paramétrer Git pour suivre les modifications dans vos dossiers,  
- connecter votre référentiel local à un référentiel en ligne distant,  
- livrer les changements,  
- synchroniser vos dépôts local et distant.  

Tout cela devrait vous permettre de démarrer et de répondre à la plupart de vos besoins en tant qu'épidémiologistes. 
épidémiologistes. Nous n'avons généralement pas un usage aussi avancé que les développeurs. 

Cependant, sachez que si vous voulez (ou devez) aller plus loin, Git offre plus de puissance pour simplifier 
l'historique des commits, le retour en arrière d'un ou plusieurs commits, le cherry-pick des commits, etc. 
Tout cela peut sembler de la pure magie, mais maintenant que vous avez les bases, 
il est plus facile de s'appuyer dessus.


Notez que si le panneau Git dans Rstudio et Github Desktop sont bons pour les débutants / l'utilisation quotidienne dans le cadre d'un projet de développement, il n'est pas nécessaire d'avoir des connaissances particulières. 
pour les débutants et l'utilisation quotidienne dans notre secteur d'activité, ils n'offrent pas d'interface pour certaines fonctions intermédiaires ou avancées. 
interface pour certaines des fonctions intermédiaires/avancées de Git. 
Certaines interfaces plus complètes vous permettent d'en faire plus en pointant et en cliquant. 
(généralement au prix d'une mise en page plus complexe). 

Rappelez-vous que puisque vous pouvez utiliser n'importe quel outil à n'importe quel moment pour suivre votre dépôt, 
vous pouvez très facilement installer une interface pour l'essayer parfois, 
ou pour effectuer occasionnellement une tâche complexe moins courante, 
tout en préférant une interface simplifiée le reste du temps (par exemple en utilisant 
Github Desktop la plupart du temps, et passer à SourceTree ou Gitbash pour certaines tâches spécifiques).


### Commandes Git {#git}


### Apprentissage recommandé {.unnumbered}

Pour apprendre les commandes Git à l'aide d'un tutoriel interactif, voir [ce
site web](https://learngitbranching.js.org/).

### Où entrer les commandes {.unnumbered}

Vous entrez les commandes dans un shell Git.

*Option 1* Vous pouvez ouvrir un nouveau Terminal dans RStudio. Cet onglet se trouve à côté de
la Console R. Si vous ne parvenez pas à y taper du texte, cliquez sur le
menu déroulant sous "Terminal" et sélectionnez "Nouveau terminal". Tapez les
dans l'espace clignotant situé devant le symbole du dollar "\$".

``{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

*Option 2* Vous pouvez également ouvrir un *shell* (un terminal pour entrer des commandes) en
cliquant sur l'icône bleue "gears" dans l'onglet Git (près de l'environnement RStudio).
Environnement). Sélectionnez "Shell" dans le menu déroulant. Une nouvelle fenêtre s'ouvre
Une nouvelle fenêtre s'ouvre dans laquelle vous pouvez saisir les commandes après le signe du dollar "\$".

*Option 3* Cliquez avec le bouton droit de la souris pour ouvrir "Git Bash here", qui ouvrira le même type de terminal.
qui ouvrira le même type de terminal, ou ouvrez *Git Bash* depuis votre liste d'applications.
[Plus d'informations pour les débutants sur Git Bash] (https://happygitwithr.com/shell.html), 
comment le trouver et quelques commandes bash dont vous aurez besoin.

### Exemples de commandes {.non numéroté}

Nous présentons ci-dessous quelques commandes git courantes. Lorsque vous les utilisez, gardez à l'esprit
quelle branche est active (check-out), car cela changera l'action !

Dans les commandes ci-dessous, <name> représente un nom de branche. 
<commit_hash> représente l'ID de hachage d'un commit spécifique.
spécifique. <num> représente un nombre. Ne tapez pas les symboles
\< ou \>>.

| Commande Git | Action |
|--------------------------|--------------------------------------------------------------------------|
| `git branch <name>` | Créer une nouvelle branche avec le nom <name> |
| `git checkout <name>` | Bascule de la branche actuelle vers <name>`.
| `git checkout -b <name>` | Raccourci pour créer une nouvelle branche *et* y basculer |
| `git status` | Voir les modifications non suivies |
| `git add <file>` | Mettre en scène un fichier |
| `git commit -m <message> `Comptabilise les changements actuellement mis en scène dans la branche actuelle avec le message |
| `git fetch` | Récupérer les commits du dépôt distant |
| `git pull` | Extraire les commits du dépôt distant dans la branche actuelle |
| `git push` | Pousse les commits locaux vers le répertoire distant |
| `git switch` | Une alternative à `git checkout` qui est en train d'être introduite progressivement dans Git |
| `git merge <name>` | Fusionner la branche <name> dans la branche courante |
| `git rebase <name>` | Ajoute les commits de la branche courante à la branche <name> |



<!-- ======================================================= -->

## Ressources

Une grande partie de cette page a été informée par [ce site "Happy Git with R"
site web](https://happygitwithr.com/) par Jenny Bryan. Il y a une section très utile
très utile qui vous aide à résoudre les erreurs courantes liées à Git et à R.
R.

Le [Guide de documentation et de démarrage de Github.com
guide] (https://docs.github.com/en/github).

La fiche technique de RStudio ["IDE"
cheatsheet] (https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
qui comprend des conseils sur Git avec RStudio.

<https://ohi-science.org/news/github-going-back-in-time>

**Les commandes Git pour les débutants**

Un [tutoriel
didacticiel](learngitbranching.js.org) pour apprendre les
les commandes Git.

<https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/> :
bon pour apprendre les bases absolues pour suivre les changements dans un dossier sur
votre propre ordinateur.

De beaux schémas pour comprendre les branches :
<https://speakerdeck.com/alicebartlett/git-for-humans>


**Tutoriels couvrant les sujets de base et plus avancés**.

<https://tutorialzine.com/2016/06/learn-git-in-30-minutes>

<https://dzone.com/articles/git-tutorial-commands-and-operations-in-git>
<https://swcarpentry.github.io/git-novice/> (cours court)
<https://rsjakob.gitbooks.io/git/content/chapter1.html>

Le [livre Pro Git](https://git-scm.com/book/en/v2) est considéré comme une référence officielle. 
Bien que certains chapitres soient corrects, il est généralement un peu _technique_. C'est probablement une bonne ressource 
une fois que vous avez utilisé Git un peu et que vous voulez apprendre un peu plus précisément 
ce qui se passe et comment aller plus loin.